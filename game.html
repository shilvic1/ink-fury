<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Ink Fury â€” Battleground</title>
<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  body { margin:0; font-family: 'Press Start 2P', monospace; background:#000; color:#fff; overflow:hidden; user-select: none; }
  
  /* --- UI & MENUS --- */
  #menu, #gameContainer { width: 100vw; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; position: absolute; top:0; left:0; }
  #gameContainer { display: none; background: #111; }

  .logo { font-size:48px; margin-bottom:20px; border: 4px solid #fff; padding: 10px; text-shadow: 4px 4px #00f; }
  .grid { display:grid; grid-template-columns:repeat(4,160px); grid-gap:16px; }
  .card { background:#111; border:2px solid #444; padding:10px; cursor:pointer; text-align:center; transition: 0.2s; position: relative; }
  .card:hover { transform:translateY(-4px); border-color:#fff; }
  .card.selected { border-color:#0f0; box-shadow: 0 0 15px rgba(0,255,0,0.5); }
  
  /* --- NEW LOCKED STYLE --- */
  .card.locked { opacity: 0.3; filter: grayscale(100%); pointer-events: none; border-color: #300; }
  .card.locked::after { content: "ELIMINATED"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-15deg); color: #f00; font-size: 10px; border: 2px solid #f00; padding: 2px; background: #000; }

  .card .name { font-size:12px; margin-bottom:4px; color: #fff; }
  .card .role { font-size:8px; opacity:0.7; color: #aaa; }
  
  #hoverInfo { position:absolute; top:20px; right:20px; background:rgba(0,0,0,0.9); padding:15px; border: 1px solid #fff; width:250px; font-size:10px; line-height: 1.6; z-index: 10; pointer-events: none; }
  .ability-list { margin-top: 10px; color: #ccc; }
  .ability-item { margin-bottom: 4px; }
  
  #startBtn { margin-top:30px; padding:15px 40px; background:#fff; color:#000; font-family: inherit; font-size:14px; border:none; cursor:pointer; opacity:0.3; transition: 0.2s; }
  #startBtn.active { opacity:1; background: #0f0; box-shadow: 0 0 20px #0f0; }
  
  /* New Network Status UI */
  #netStatus { margin-top: 10px; font-size: 10px; color: #0ff; text-align: center; height: 20px; }

  /* --- CONTROLS HUD --- */
  #controls-hud {
    position: absolute;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.7);
    border: 1px solid #555;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 50;
    pointer-events: none;
  }
  
  .ctrl-row {
    display: flex;
    align-items: center;
    font-size: 8px;
    color: #ccc;
  }
  
  .ctrl-key {
    width: 20px;
    height: 20px;
    background: #222;
    border: 1px solid #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 10px;
    color: #ff0;
    font-size: 8px;
    box-shadow: 2px 2px #000;
    transition: 0.1s;
  }
  .ctrl-key.wide { width: 50px; }
  
  /* Cooldown Visuals for Keys */
  .ctrl-key.cooldown {
    border-color: #f00;
    color: #f00;
    background: #300;
  }

  /* --- IN-GAME HUD --- */
  canvas { background: #1a1a1a; display: block; image-rendering: pixelated; }

  #ui-hud { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); text-align: center; width: 100%; pointer-events: none; }
  #charNameDisplay { font-size: 20px; margin-bottom: 15px; letter-spacing: 2px; text-shadow: 2px 2px #000; }
  
  /* NEW ROUND SCORE DISPLAY */
  #round-display { 
    position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
    font-size: 16px; color: #fff; text-shadow: 2px 2px #000; 
    border: 1px solid #fff; padding: 5px 15px; background: rgba(0,0,0,0.5);
    z-index: 60; pointer-events: none;
  }

  .ability-grid { display: flex; justify-content: center; gap: 15px; }
  .ability-slot { 
    width: 60px; height: 60px; background: rgba(0,0,0,0.8); border: 2px solid #555; 
    display: flex; flex-direction: column; align-items: center; justify-content: center; 
    font-size: 8px; position: relative; overflow: hidden; color: #fff;
  }
  .ability-slot.ready { border-color: #0ff; box-shadow: 0 0 10px #0ff; }
  .ability-slot .key { position: absolute; top: 2px; left: 2px; color: #ff0; font-size: 8px; font-weight: bold; }
  .ability-slot .name { padding: 0 4px; text-align: center; z-index: 2; }
  .cooldown-overlay { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(255, 0, 0, 0.6); transition: height 0.1s linear; z-index: 1; }

  /* Health Bars */
  #health-containers { position: absolute; top: 0; left: 0; width: 100%; height: 0; overflow: visible; }
  .hp-bar-wrap { position: absolute; width: 60px; height: 8px; background: #333; border: 1px solid #000; transform: translate(-50%, -100%); transition: top 0.1s, left 0.1s; pointer-events: none; }
  .hp-bar-fill { height: 100%; background: #0f0; width: 100%; transition: width 0.1s; }
  
  #game-message {
    position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
    font-size: 40px; color: #fff; text-shadow: 4px 4px #f00; display: none;
    z-index: 100;
  }

  /* Countdown Text */
  #countdown {
    position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
    font-size: 80px; color: #ff0; text-shadow: 5px 5px #f00; 
    display: none; z-index: 99; pointer-events: none;
  }
</style>
</head>
<body>

<div id="menu">
    <div class="logo">INK FURY</div>
    <div class="grid" id="charGrid"></div>
    <div id="hoverInfo">SELECT FIGHTER</div>
    <div id="netStatus"></div>
    <button id="startBtn">ENTER BATTLEGROUND</button>
</div>

<div id="gameContainer">
    <div id="round-display">ROUND 1 | 0 - 0</div>
    
    <div id="health-containers"></div>
    <div id="controls-hud">
        <div class="ctrl-row"><div class="ctrl-key">A</div><div class="ctrl-key">D</div> MOVE</div>
        <div class="ctrl-row"><div class="ctrl-key wide">SPACE</div> DOUBLE JUMP</div>
        <div class="ctrl-row"><div class="ctrl-key">S</div> DROP</div>
        <div class="ctrl-row"><div class="ctrl-key" id="key-q">Q</div> DASH</div>
        <div class="ctrl-row"><div class="ctrl-key" id="key-e">E</div> RUSH</div>
        <div class="ctrl-row"><div class="ctrl-key" id="key-r">R</div> HEAVY</div>
        <div class="ctrl-row"><div class="ctrl-key" id="key-f">F</div> BLOCK</div>
        <div class="ctrl-row"><div class="ctrl-key">M1</div> ATTACK</div>
        <div class="ctrl-row"><div class="ctrl-key">1-4</div> SKILLS</div>
    </div>
    <div id="countdown">3</div>
    <div id="game-message">VICTORY</div>
    <div id="ui-hud">
        <div id="charNameDisplay">PLAYER</div>
        <div class="ability-grid" id="abilityGrid"></div>
    </div>
    <canvas id="gameCanvas"></canvas>
</div>

<script>
// --- GAME DATA ---
const CHARACTERS = [
  { 
    name:"Volt", color:"#0cf", role:"All-Rounder", 
    desc: "Fast, adaptable fighter with mobility and burst.",
    abilities:["Dash Strike","Ink Shot","Uppercut","Ink Burst"] 
  },
  { 
    name:"Flash", color:"#ff0", role:"Speed", 
    desc: "Extreme mobility and hit-and-run pressure.",
    abilities:["Quick Dash","Rapid Strike","Wall Jump","Afterimage"] 
  },
  { 
    name:"Titan", color:"#f44", role:"Strength", 
    desc: "High damage bruiser that dominates close combat.",
    abilities:["Power Slam","Ground Smash","Shockwave","Heavy Punch"] 
  },
  { 
    name:"Shade", color:"#a0f", role:"Stealth", 
    desc: "High-risk assassin specializing in surprise attacks.",
    abilities:["Vanish","Backstab","Shadow Step","Smoke Bomb"] 
  },
  { 
    name:"Gadget", color:"#5f5", role:"Utility", 
    desc: "Battlefield control and team support specialist.",
    abilities:["Trap","Barrier","Heal Pulse","Drone Strike"] 
  },
  { 
    name:"Blaze", color:"#f80", role:"Elemental", 
    desc: "Area damage mage with strong zone control.",
    abilities:["Fireball","Flame Dash","Burn AoE","Inferno"] 
  },
  { 
    name:"Arrow", color:"#fff", role:"Ranged", 
    desc: "Precision damage dealer with traps and burst.",
    abilities:["Snipe","Piercing Arrow","Trap Shot","Multi Shot"] 
  },
  { 
    name:"Anchor", color:"#840", role:"Tank", 
    desc: "Frontline protector that controls enemy movement.",
    abilities:["Shield Bash","Wall Smash","Taunt","Earthquake"] 
  },
];

// --- MENU LOGIC ---
const charGrid = document.getElementById("charGrid");
const hoverInfo = document.getElementById("hoverInfo");
const netStatus = document.getElementById("netStatus");
let selectedChar = null;

// --- ROUND & SCORE STATE ---
let currentRound = 1;
let myScore = 0;
let enemyScore = 0;
let myLockedChars = []; // Stores indices of characters I won with

function renderCharGrid() {
    charGrid.innerHTML = "";
    CHARACTERS.forEach((c, idx)=>{
      const card = document.createElement("div");
      card.classList.add("card");
      
      // Check if locked
      if(myLockedChars.includes(idx)) {
          card.classList.add("locked");
      }

      card.innerHTML = `<div class="name">${c.name}</div><div class="role">${c.role}</div>`;
      card.dataset.index = idx; 
      charGrid.appendChild(card);
      
      card.onmouseenter = () => {
        if(card.classList.contains("locked")) {
             hoverInfo.innerHTML = "CHARACTER ELIMINATED (WINNER)";
             return;
        }
        hoverInfo.innerHTML = `
          <b style="font-size:14px; color:${c.color}">${c.name}</b><br>
          <i style="color:#aaa">${c.role}</i><br>
          <div style="margin:10px 0; font-size:9px">${c.desc}</div>
          <div class="ability-list">
            ${c.abilities.map((a,i) => `<div class="ability-item"><span style="color:${c.color}">${i+1}.</span> ${a}</div>`).join("")}
          </div>
        `;
      };

      card.onclick = ()=>{
        if(card.classList.contains("locked")) return; // Cannot select
        if(isMultiplayer && imReady) return;

        document.querySelectorAll(".card").forEach(x=>x.classList.remove("selected"));
        card.classList.add("selected");
        selectedChar = c;
        selectedCharIndex = idx;
        document.getElementById("startBtn").classList.add("active");
      };
    });
}

// Initial render
renderCharGrid();


// --- ENGINE VARIABLES ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const hpContainer = document.getElementById('health-containers');
const countdownEl = document.getElementById('countdown');

let gameLoopId;
let entities = [];
let particles = [];
let projectiles = [];
let texts = [];
let platforms = []; // Stores platform objects
let player, enemy;
let screenShake = 0;

let matchActive = false; // Prevents moving during countdown

// Input State
const keys = { w:false, a:false, s:false, d:false, f:false, shift:false, " ":false, q:false, e:false, r:false, 1:false, 2:false, 3:false, 4:false };
const mouse = { x:0, y:0, down:false };

// Physics Constants
const GRAVITY = 0.9; 
const FRICTION = 0.88; 
const JUMP_FORCE = -12; // Increased slightly for better airtime
const MOVE_SPEED = 0.8; 
const WALL_THICKNESS = 50; 

// --- NEW BACKGROUND SYSTEM ---
class BackgroundSystem {
    constructor() {
        this.themes = ["City", "Arena", "Battlefield"];
        this.currentTheme = "City";
        this.offset = 0;
    }

    pickRandomTheme() {
        this.currentTheme = this.themes[Math.floor(Math.random() * this.themes.length)];
        console.log("Selected Theme:", this.currentTheme);
    }

    update() {
        // Slow parallax scroll
        this.offset += 0.5;
    }

    draw(ctx, w, h) {
        // Clear black
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, w, h);

        if (this.currentTheme === "City") {
            // -- FUTURISTIC CITY --
            // Sky Gradient
            let grd = ctx.createLinearGradient(0, 0, 0, h);
            grd.addColorStop(0, "#001");
            grd.addColorStop(1, "#204");
            ctx.fillStyle = grd;
            ctx.fillRect(0,0,w,h);

            // Far Buildings (Slowest)
            ctx.fillStyle = "#050510";
            for(let i=0; i<20; i++) {
                let bx = (i*100) - (this.offset * 0.2) % 2000;
                let bh = 150 + Math.sin(i)*50;
                ctx.fillRect(bx, h - 200 - bh, 60, bh + 200);
            }

            // Near Buildings (Mid speed)
            ctx.fillStyle = "#101020";
            for(let i=0; i<15; i++) {
                let bx = (i*150) - (this.offset * 0.5) % 2250;
                let bh = 100 + Math.cos(i*2)*80;
                ctx.fillRect(bx, h - 150 - bh, 80, bh + 150);
                
                // Windows (Neon)
                ctx.fillStyle = (i%3===0) ? "#0ff" : "#f0f";
                if(Math.random()>0.9) ctx.fillRect(bx+10, h-150-bh+20, 5, 5); // Flicker
                ctx.fillStyle = "#101020"; // reset
            }
        } 
        else if (this.currentTheme === "Arena") {
            // -- UNDERGROUND ARENA --
            ctx.fillStyle = "#111";
            ctx.fillRect(0,0,w,h);
            
            // Grime/Walls
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 2;
            for(let i=0; i<w; i+=50) {
                ctx.beginPath(); 
                ctx.moveTo(i, 0); 
                ctx.lineTo(i, h); 
                ctx.stroke();
            }

            // Pipes
            ctx.fillStyle = "#222";
            ctx.fillRect(0, 100, w, 30);
            ctx.fillRect(0, h-150, w, 40);
            
            // Chains
            ctx.strokeStyle = "#444";
            for(let i=0; i<w; i+=120) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, h/2 + Math.sin(this.offset/20 + i)*20);
                ctx.stroke();
            }
            
            // Graffiti text
            ctx.font = "100px Arial";
            ctx.fillStyle = "rgba(255, 0, 0, 0.1)";
            ctx.fillText("FIGHT", w/2 - 150 - (this.offset*0.5)%w, h/2);
        }
        else if (this.currentTheme === "Battlefield") {
            // -- BATTLEFIELD --
            // Red Sky
            let grd = ctx.createLinearGradient(0, 0, 0, h);
            grd.addColorStop(0, "#310");
            grd.addColorStop(1, "#520");
            ctx.fillStyle = grd;
            ctx.fillRect(0,0,w,h);
            
            // Smoke Clouds
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            for(let i=0; i<10; i++) {
                let cx = (i*200) - (this.offset) % (w+400);
                let cy = h/2 + Math.sin(i + this.offset/50)*50;
                ctx.beginPath();
                ctx.arc(cx, cy, 80, 0, Math.PI*2);
                ctx.fill();
            }
            
            // Debris (Ground)
            ctx.fillStyle = "#110";
            ctx.beginPath();
            ctx.moveTo(0, h-50);
            for(let i=0; i<=w; i+=50) {
                ctx.lineTo(i, h-50 - Math.abs(Math.sin(i)*20));
            }
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.fill();
        }
    }
}

const bgSystem = new BackgroundSystem();

// --- NETWORK VARIABLES ---
const urlParams = new URLSearchParams(window.location.search);
const gameMode = urlParams.get('mode') || 'vsai'; 
const roomID = urlParams.get('room');
const role = urlParams.get('role'); // host or join
const teamMode = urlParams.get('team') || '1v1';
const username = urlParams.get('user') || 'Player';

let isMultiplayer = (gameMode === 'online');
let peer = null;
let conn = null;
let imReady = false;
let peerReady = false;
let selectedCharIndex = 0;
let peerCharIndex = 0; 
let peerKeys = {}; 
let peerMouse = { x:0, y:0 };

// --- CLASSES ---

class Particle {
    constructor(x, y, color, speed, size, life, isFire = false) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.color = color;
        this.size = size;
        this.life = life;
        this.maxLife = life;
        this.isFire = isFire;
        if(isFire) {
             this.vy = -Math.random() * 2 - 1; // Float up
        }
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.size *= 0.95;
        
        if (this.isFire) {
            // Shift color yellow -> red -> dark
            const r = 255;
            const g = Math.floor((this.life/this.maxLife) * 200);
            this.color = `rgb(${r}, ${g}, 0)`;
        }
    }
    draw(ctx) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

class FloatingText {
    constructor(x, y, text, color) {
        this.x = x; this.y = y;
        this.text = text;
        this.color = color;
        this.life = 60;
        this.vy = -1;
    }
    update() {
        this.y += this.vy;
        this.life--;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life / 60);
        ctx.fillStyle = this.color;
        ctx.font = "10px 'Press Start 2P'";
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
    }
}

class Projectile {
    constructor(owner, x, y, dir, type) {
        this.owner = owner;
        this.x = x; this.y = y;
        this.w = 20; this.h = 20;
        this.dir = dir;
        this.type = type;
        this.life = 100;
        this.active = true;
        this.vx = dir * 15;
        this.vy = 0;
        this.color = owner.color;
        
        // Custom projectile logic
        if(type === "Ink Shot") { this.vx = dir * 18; this.dmg = 15; }
        else if(type === "Fireball") { this.vx = dir * 12; this.w = 30; this.h = 30; this.dmg = 20; this.color = "#f80"; }
        else if(type === "Snipe") { this.vx = dir * 30; this.w = 40; this.h = 5; this.dmg = 35; }
        else if(type === "RapidHit") { this.vx = dir * 20; this.w = 15; this.h = 15; this.dmg = 6; this.life = 10; }
        else if(type === "Trap Shot") { this.vx = dir * 12; this.dmg = 5; this.effect = "slow"; }
        else if(type === "Landmine") { 
            this.vx = 0; this.vy = 0; this.life = 9999; this.w=30; this.h=10; this.color="#f00"; this.dmg = 40;
            this.y = owner.y + owner.h - 10;
        }
        else if(type === "Drone Strike") {
            this.vx = dir * 5; this.vy = -5; this.life = 150; this.dmg = 25; this.color="#0f0";
        }
        else { this.dmg = 10; }
    }
    
    update() {
        // --- HOMING LOGIC FOR DRONE ---
        if (this.type === "Drone Strike" && this.active) {
            const target = this.owner.isPlayer ? enemy : player;
            if (!target.dead) {
                const dx = (target.x + target.w/2) - this.x;
                const dy = (target.y + target.h/2) - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 0) {
                    this.vx += (dx / dist) * 1.5; 
                    this.vy += (dy / dist) * 1.5;
                    const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                    if (speed > 12) {
                        this.vx = (this.vx / speed) * 12;
                        this.vy = (this.vy / speed) * 12;
                    }
                }
            }
            particles.push(new Particle(this.x, this.y, "#0f0", 0, 5, 10));
        }

        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        if(this.life <= 0) this.active = false;
        
        // Particles
        if(Math.random() > 0.5 && this.type !== "Landmine") particles.push(new Particle(this.x, this.y, this.color, 5, 4, 20, this.type === "Fireball"));
        
        // Pulse Effect for Landmine
        if(this.type === "Landmine") {
            if(Math.floor(Date.now()/200)%2===0) this.color = "#f00"; else this.color = "#500";
        }

        // --- WALL COLLISION (CANCEL PROJECTILE) ---
        if (this.type !== "Landmine") { 
            if (this.x < WALL_THICKNESS || this.x > canvas.width - WALL_THICKNESS) {
                this.active = false;
                for(let i=0; i<8; i++) {
                     particles.push(new Particle(this.x, this.y, "#fff", 5, 5, 15));
                }
                return; 
            }
        }

        // Entity Collision
        entities.forEach(e => {
            if (isMultiplayer && this.owner.isRemotePlayer) return;
            if (e !== this.owner && !e.dead) {
                if (this.x < e.x + e.w && this.x + this.w > e.x &&
                    this.y < e.y + e.h && this.y + this.h > e.y) {
                    
                    if (this.type === "Landmine") {
                         createFireExplosion(this.x, this.y);
                         screenShake = 20;
                         entities.forEach(victim => {
                             const dist = Math.sqrt(Math.pow(this.x - victim.x, 2) + Math.pow(this.y - victim.y, 2));
                             if (dist < 100) {
                                 victim.takeDamage(40, (victim.x > this.x ? 1 : -1), 15, 40);
                                 victim.vy = -15; 
                                 if(isMultiplayer && conn && victim.isRemotePlayer) {
                                     conn.send({type: 'hit_confirm', dmg: 40, dir: (victim.x > this.x ? 1 : -1), kb: 15, stun: 40, lift: -15 });
                                 }
                             }
                         });
                         this.active = false;
                         return;
                    }

                    e.takeDamage(this.dmg, this.dir, 5);
                    if(this.effect === "slow") e.applyStatus("slow", 120);
                    if(this.type === "Fireball" || this.type === "Drone Strike") createFireExplosion(this.x, this.y);
                    
                    if (isMultiplayer && conn && e.isRemotePlayer) {
                        conn.send({ type: 'hit_confirm', dmg: this.dmg, dir: this.dir, kb: 5, stun: 0 });
                    }

                    this.active = false;
                    for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, this.color, 10, 5, 30));
                }
            }
        });
    }
    
    draw(ctx) {
        ctx.fillStyle = this.color;
        if (this.type === "Snipe") ctx.fillRect(this.x, this.y, this.w, this.h);
        else if (this.type === "Landmine") {
             ctx.fillRect(this.x, this.y, this.w, this.h);
             ctx.fillStyle = "#fff";
             ctx.fillRect(this.x + 10, this.y - 2, 10, 4);
        }
        else ctx.beginPath(), ctx.arc(this.x+this.w/2, this.y+this.h/2, this.w/2, 0, Math.PI*2), ctx.fill();
    }
}

class Entity {
    constructor(x, y, color, isPlayer, charData, isRemotePlayer = false) {
        this.x = x; this.y = y;
        this.w = 40; this.h = 70;
        this.color = color;
        this.isPlayer = isPlayer;
        this.isRemotePlayer = isRemotePlayer; 
        this.charData = charData; 
        this.maxHp = 200;
        this.hp = 200;
        
        this.vx = 0; this.vy = 0;
        this.facing = 1; 
        
        this.grounded = false;
        
        // --- DOUBLE JUMP VARS ---
        this.jumps = 0;
        this.maxJumps = 2; // Allow double jump

        this.isDashing = false;
        
        // Timers
        this.dashTimer = 0;
        this.rushTimer = 0;
        
        // Combat States
        this.state = "idle"; 
        this.attackTimer = 0;
        this.attackType = "light";
        this.counterActive = false; 
        
        // Cooldowns
        this.cooldowns = { heavy: 0, dash: 0, rush: 0, a1: 0, a2: 0, a3: 0, a4: 0, block: 0 };
        this.invulnTimer = 0;
        this.dead = false;
        
        // Status
        this.invisible = false;
        this.speedMod = 1;
        this.shield = 0; 
        
        this.hpBar = document.createElement('div');
        this.hpBar.className = "hp-bar-wrap";
        this.hpBar.innerHTML = `<div class="hp-bar-fill"></div>`;
        hpContainer.appendChild(this.hpBar);

        this.melting = false;
        this.meltTimer = 1.0; 
    }

    update() {
        if (this.dead) return;
        
        if (this.melting) {
            this.meltTimer -= 0.015; 
            if(Math.random() > 0.3) {
                particles.push(new Particle(this.x + (Math.random() * this.w * (2 - this.meltTimer)) - 10, this.y + this.h, this.color, 2, 4, 30));
            }
            if (this.meltTimer <= 0) {
                this.meltTimer = 0;
                this.dead = true; 
                if(!this.isPlayer) {
                     document.getElementById("game-message").innerText = "VICTORY";
                     document.getElementById("game-message").style.display = "block";
                     document.getElementById("game-message").style.color = "#0f0";
                     setTimeout(() => endRound(true), 3000);
                } else {
                     document.getElementById("game-message").innerText = "DEFEAT";
                     document.getElementById("game-message").style.display = "block";
                     document.getElementById("game-message").style.color = "#f00";
                     setTimeout(() => endRound(false), 3000);
                }
            }
            return;
        }
        
        if (isMultiplayer && this.isRemotePlayer && matchActive) {
            this.handleRemoteInput();
        }

        if (this.state !== "rush") {
            this.vy += GRAVITY;
        }

        this.vx *= FRICTION;
        this.x += this.vx * this.speedMod;
        this.y += this.vy;

        // --- PLATFORM COLLISION ---
        this.grounded = false; // Assume in air first

        // 1. Floor Collision
        if (this.y + this.h > canvas.height - 50) {
            this.y = canvas.height - 50 - this.h;
            if (this.state === "attack" && this.attackType === "down_slam" && this.vy > 10) {
                 screenShake = 15;
                 createFireExplosion(this.x + this.w/2, this.y + this.h);
                 this.state = "idle"; 
            }
            if(this.state !== "rush") {
                this.vy = 0;
                this.grounded = true;
                this.jumps = 0; // Reset jump count
            }
        } 

        // 2. Floating Platforms (One-way)
        let dropDown = (this.isPlayer && keys['s']) || (isMultiplayer && this.isRemotePlayer && peerKeys['s']);

        if (this.vy >= 0 && !dropDown) {
            platforms.forEach(plat => {
                if (this.x + this.w > plat.x && this.x < plat.x + plat.w &&
                    this.y + this.h >= plat.y && this.y + this.h <= plat.y + 25) { 
                    
                    this.y = plat.y - this.h;
                    this.vy = 0;
                    this.grounded = true;
                    this.jumps = 0; // Reset jump count
                }
            });
        }
        
        // --- WALL COLLISION ---
        if(this.x < WALL_THICKNESS) { this.x = WALL_THICKNESS; this.vx = 0; }
        if(this.x > canvas.width - WALL_THICKNESS - this.w) { this.x = canvas.width - WALL_THICKNESS - this.w; this.vx = 0; }

        this.invulnTimer--;
        for(let k in this.cooldowns) if(this.cooldowns[k] > 0) this.cooldowns[k]--;
        
        if (this.state === "stun") {
            this.attackTimer--;
            if (this.attackTimer <= 0) this.state = "idle";
        } 
        else if (this.state === "blocking") {
            this.attackTimer--;
            this.vx *= 0.8; 
            if (this.attackTimer <= 0) this.state = "idle";
        }
        else if (this.state === "attack") {
            this.attackTimer--;
            if (this.attackTimer === 5 || this.attackTimer === 35 || this.attackTimer === 2) this.spawnHitbox(); 
            if (this.attackTimer <= 0) this.state = "idle";
        }
        else if (this.state === "dash_attack") {
            this.dashTimer--;
            this.vx = this.facing * 25; 
            this.vy = 0; 
            if(this.dashTimer % 2 === 0) particles.push(new Particle(this.x, this.y, this.color, 0, 40, 10)); 
            if (this.dashTimer <= 0) {
                this.vx = 0;
                this.performAttack("dash_finisher");
            }
        }
        else if (this.state === "rush") {
            this.rushTimer--;
            particles.push(new Particle(this.x, this.y, "#0ff", 0, 30, 10));
            const target = this.isPlayer ? enemy : player;
            if (!this.isRemotePlayer) { 
                if (this.x < target.x + target.w && this.x + this.w > target.x &&
                    this.y < target.y + target.h && this.y + this.h > target.y) {
                        target.takeDamage(20, this.facing, 10, 20);
                        this.state = "idle";
                        this.vx = -this.facing * 5; 
                        this.vy = -5;
                        createFireExplosion(target.x, target.y);
                        if(isMultiplayer && conn) {
                            conn.send({ type: 'hit_confirm', dmg: 20, dir: this.facing, kb: 10, stun: 20 });
                        }
                }
            }
            if (this.rushTimer <= 0) {
                this.state = "idle";
                this.vx = this.vx * 0.2; 
            }
        }
        
        const fill = this.hpBar.querySelector('.hp-bar-fill');
        fill.style.width = (this.hp / this.maxHp * 100) + "%";
        this.hpBar.style.left = (this.x + this.w/2) + "px";
        this.hpBar.style.top = (this.y - 10) + "px";
        
        if (!this.isPlayer && !this.isRemotePlayer && matchActive) this.aiLogic();
    }

    handleRemoteInput() {
        if(this.state === "stun" || this.state === "dash_attack" || this.state === "rush" || this.state === "blocking") return;
        if (peerKeys['a']) { this.vx -= MOVE_SPEED; this.facing = -1; }
        if (peerKeys['d']) { this.vx += MOVE_SPEED; this.facing = 1; }
        // Jump is handled via action sync now to prevent glitching
    }

    aiLogic() {
        if(this.state === "stun" || this.state === "attack" || this.state === "dash_attack" || this.state === "rush" || this.state === "blocking") return;
        const target = player;
        const dist = Math.abs(target.x - this.x);
        const yDist = target.y - this.y;
        this.facing = (target.x - this.x) > 0 ? 1 : -1;

        if (dist > 250 && Math.random() < 0.02 && this.cooldowns.rush <= 0) {
             this.performAttack("rush");
             return;
        }

        if (yDist < -50 && dist < 50 && this.grounded) {
             this.vy = JUMP_FORCE;
             setTimeout(() => this.performAttack("light"), 100); 
             return;
        }

        if (dist > 200 && this.cooldowns.dash <= 0) {
            this.performAttack("dash");
            return;
        }

        if (dist < 70) {
            if (player.state === "attack" && Math.random() < 0.3) {
                this.performAttack("block");
                return;
            }
            if (this.cooldowns.heavy <= 0 && Math.random() < 0.05) {
                this.performAttack("heavy");
            } 
            else if (Math.random() < 0.1) {
                this.performAttack("light");
            }
        } else {
            this.vx += this.facing * MOVE_SPEED;
            if (this.grounded && Math.random() < 0.02) this.vy = JUMP_FORCE;
        }
        
        if (Math.random() < 0.01) {
            const r = Math.floor(Math.random()*4);
            this.useAbility(r);
        }
    }

    performAttack(type, targetMouse) {
        if (this.state === "stun" || this.state === "attack" || this.state === "dash_attack" || this.state === "rush") return;

        if (type === "light") {
            if (!this.grounded) {
                if (this.vy < 0) type = "uppercut";
                else if (this.vy > 0) type = "down_slam";
            }
        }

        if (type === "light") {
            this.state = "attack";
            this.attackTimer = 20; 
            this.attackType = "light";
        }
        else if (type === "uppercut") {
            this.state = "attack";
            this.attackTimer = 25;
            this.attackType = "uppercut";
            texts.push(new FloatingText(this.x, this.y - 30, "UPPERCUT!", "#ff0"));
        }
        else if (type === "down_slam") {
            this.state = "attack";
            this.attackTimer = 25;
            this.attackType = "down_slam";
            this.vy = 25; 
            texts.push(new FloatingText(this.x, this.y - 30, "SLAM!", "#f44"));
        }
        else if (type === "block") {
            if (this.cooldowns.block > 0 && !this.isRemotePlayer) return;
            this.state = "blocking";
            this.attackTimer = 60; 
            texts.push(new FloatingText(this.x, this.y - 30, "GUARD", "#fff"));
        }
        else if (type === "heavy") {
            if (this.cooldowns.heavy > 0 && !this.isRemotePlayer) return;
            this.cooldowns.heavy = 300; 
            this.state = "attack";
            this.attackTimer = 50; 
            this.attackType = "heavy";
            texts.push(new FloatingText(this.x, this.y-20, "CHARGING!", "#f00"));
        } 
        else if (type === "dash") {
            if (this.cooldowns.dash > 0 && !this.isRemotePlayer) return;
            this.cooldowns.dash = 180;
            this.state = "dash_attack";
            this.dashTimer = 10; 
        }
        else if (type === "dash_finisher") {
            this.state = "attack";
            this.attackTimer = 15;
            this.attackType = "dash_hit";
        }
        else if (type === "rush") {
            if(this.cooldowns.rush > 0 && !this.isRemotePlayer) return;
            this.cooldowns.rush = 300; 
            this.state = "rush";
            this.rushTimer = 15;
            
            let targetX, targetY;
            if (this.isPlayer) {
                targetX = mouse.x;
                targetY = mouse.y;
            } else if (this.isRemotePlayer) {
                targetX = peerMouse.x;
                targetY = peerMouse.y;
            } else {
                targetX = player.x;
                targetY = player.y;
            }
            
            const dx = targetX - (this.x + this.w/2);
            const dy = targetY - (this.y + this.h/2);
            const angle = Math.atan2(dy, dx);
            this.facing = dx > 0 ? 1 : -1;
            const speed = 30;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            texts.push(new FloatingText(this.x, this.y-40, "RUSH!", "#0ff"));
        }
    }

    useAbility(index) {
        if (!matchActive) return;
        if (this.state !== "idle" && this.state !== "run" && this.state !== "jump") return;
        const key = "a"+(index+1);
        if (this.cooldowns[key] > 0 && !this.isRemotePlayer) return;
        const abilityName = this.charData.abilities[index];
        this.cooldowns[key] = 240; 
        texts.push(new FloatingText(this.x, this.y-40, abilityName.toUpperCase(), "#fff"));
        executeAbility(this, abilityName);
    }

    spawnHitbox() {
        let dmg = 0, kb = 0, stun = 0, range = 0, h = 0, yOffset = 0;
        let lift = -5;
        let isHeavy = false;
        
        if (this.attackType === "light") {
            dmg = 10; kb = 5; stun = 15; range = 50; h = 40; yOffset = 20;
        } 
        else if (this.attackType === "uppercut") {
            dmg = 15; kb = 2; lift = -18; stun = 30; range = 40; h = 60; yOffset = 0;
        }
        else if (this.attackType === "down_slam") {
            dmg = 18; kb = 5; lift = 15; stun = 30; range = 45; h = 60; yOffset = 30;
            screenShake = 10;
        }
        else if (this.attackType === "heavy") {
            if(this.attackTimer !== 5) return; 
            dmg = 45; kb = 25; stun = 60; range = 80; h = 70; yOffset = 20; isHeavy = true;
            screenShake = 15;
            createFireExplosion(this.x + (this.facing*50), this.y+20);
        } 
        else if (this.attackType === "dash_hit") {
            dmg = 25; kb = 10; stun = 30; range = 60; h = 50; yOffset = 20;
        }

        const target = this.isPlayer ? enemy : player;
        if (this.isRemotePlayer) return; 

        const hitX = this.facing === 1 ? this.x + this.w : this.x - range;
        const hitY = this.y + yOffset;
        
        if (hitX < target.x + target.w && hitX + range > target.x &&
            hitY < target.y + target.h && hitY + h > target.y) {
            
            target.takeDamage(dmg, this.facing, kb, stun);
            target.vy = lift; 
            if (isMultiplayer && conn) {
                conn.send({
                    type: 'hit_confirm',
                    dmg: dmg,
                    dir: this.facing,
                    kb: kb,
                    stun: stun,
                    lift: lift
                });
            }
            for(let i=0; i<5; i++) particles.push(new Particle(hitX, hitY, "#fff", 5, 3, 10));
        }
    }

    takeDamage(amount, dir, knockback, stunFrames = 0) {
        if (this.state === "blocking") {
            this.state = "idle"; 
            this.cooldowns.block = 300; 
            texts.push(new FloatingText(this.x, this.y - 40, "PARRY!", "#fff"));
            if (!this.isRemotePlayer) {
                 const attacker = this.isPlayer ? enemy : player;
                 attacker.applyStun(105); 
                 if(isMultiplayer && conn) {
                     conn.send({ type: 'parry_hit', duration: 105 });
                 }
            }
            for(let i=0; i<10; i++) particles.push(new Particle(this.x+this.w/2, this.y+20, "#fff", 8, 4, 20));
            screenShake = 10;
            return; 
        }

        if (this.counterActive) {
            texts.push(new FloatingText(this.x, this.y - 40, "COUNTER!", "#fff"));
            this.counterActive = false; 
            if (!this.isRemotePlayer) {
                 const attacker = this.isPlayer ? enemy : player;
                 attacker.takeDamage(amount * 1.5, -dir, 15, 40); 
                 if(isMultiplayer && conn) {
                     conn.send({ type: 'hit_confirm', dmg: amount*1.5, dir: -dir, kb: 15, stun: 40 });
                 }
            }
            return; 
        }

        if (this.invulnTimer > 0 || this.dead) {
             return;
        }

        if (this.shield > 0) {
            if (this.shield >= amount) {
                this.shield -= amount;
                texts.push(new FloatingText(this.x, this.y, "BLOCKED", "#0ff"));
                return; 
            } else {
                amount -= this.shield;
                this.shield = 0;
                texts.push(new FloatingText(this.x, this.y, "SHIELD BREAK", "#0ff"));
            }
        }

        this.hp -= amount;
        this.invulnTimer = 15;
        this.vx = dir * knockback;
        if (stunFrames > 0) {
            this.applyStun(stunFrames);
        }
        screenShake = 5;
        texts.push(new FloatingText(this.x, this.y, "-" + amount, "#f00"));
        for(let i=0; i<8; i++) particles.push(new Particle(this.x+this.w/2, this.y+this.h/2, "#f00", 6, 4, 30));

        if (this.hp <= 0) {
            this.die();
        }
    }
    
    applyStun(duration) {
        this.state = "stun";
        this.attackTimer = duration;
    }
    
    applyStatus(type, duration) {
        if(type === "slow") { this.speedMod = 0.5; setTimeout(()=> this.speedMod=1, duration*16); }
    }

    die() {
        if (this.dead || this.melting) return;
        this.melting = true; 
        this.hp = 0;
        this.hpBar.style.display = 'none';
        for(let i=0; i<30; i++) particles.push(new Particle(this.x, this.y, this.color, 15, 6, 60));
    }

    draw(ctx) {
        if (this.invisible) ctx.globalAlpha = 0.2;

        if (this.melting) {
            ctx.fillStyle = this.color;
            const currentH = this.h * this.meltTimer;
            const currentW = this.w * (1 + (1 - this.meltTimer) * 2); 
            const xOffset = (currentW - this.w) / 2;
            const yOffset = this.h - currentH; 

            ctx.beginPath();
            ctx.ellipse(this.x + this.w/2, this.y + yOffset + currentH, currentW/2, currentH, 0, Math.PI, 0);
            ctx.fill();
            
            if (this.meltTimer > 0.3) {
                ctx.fillStyle = "#000";
                ctx.fillRect(this.x + 10, this.y + yOffset + 10, 5, 5);
                ctx.fillRect(this.x + 25, this.y + yOffset + 10, 5, 5);
            }
            ctx.globalAlpha = 1;
            return; 
        }
        
        ctx.strokeStyle = this.state === "stun" ? "#555" : this.color;
        if (this.counterActive) ctx.strokeStyle = "#fff"; 
        if (this.invulnTimer > 0 && Math.floor(Date.now()/50)%2===0) ctx.strokeStyle = "transparent";
        
        ctx.lineWidth = 4;
        const cx = this.x + this.w/2;
        const cy = this.y + 20;

        ctx.beginPath();
        ctx.arc(cx, cy, 10, 0, Math.PI*2);
        ctx.moveTo(cx, cy+10); ctx.lineTo(cx, cy+40);
        
        if(Math.abs(this.vx) > 1 && this.grounded) {
             ctx.moveTo(cx, cy+40); ctx.lineTo(cx-10 + Math.sin(Date.now()/100)*10, cy+70);
             ctx.moveTo(cx, cy+40); ctx.lineTo(cx+10 - Math.sin(Date.now()/100)*10, cy+70);
        } else {
             ctx.moveTo(cx, cy+40); ctx.lineTo(cx-10, cy+70);
             ctx.moveTo(cx, cy+40); ctx.lineTo(cx+10, cy+70);
        }

        if (this.state === "attack") {
            if(this.attackType === "heavy") {
                 const progress = 1 - (this.attackTimer / 50);
                 const angle = (Math.PI) * progress;
                 ctx.moveTo(cx, cy+15); 
                 ctx.lineTo(cx + (30*this.facing), cy + 15 + (Math.sin(angle)*20));
            } else if (this.attackType === "uppercut") {
                 ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (15*this.facing), cy-15);
            } else if (this.attackType === "down_slam") {
                 ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (15*this.facing), cy+40);
            } else {
                 ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (25*this.facing), cy+20);
            }
        } 
        else if (this.state === "rush") {
            ctx.moveTo(cx, cy+15); ctx.lineTo(cx - (20*this.facing), cy+10);
        }
        else if (this.counterActive) {
            ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (15*this.facing), cy+10);
            ctx.moveTo(cx + (15*this.facing), cy+10); ctx.lineTo(cx + (15*this.facing), cy+30);
        }
        else if (this.state === "blocking") {
            ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (10*this.facing), cy+5); 
            ctx.moveTo(cx, cy+25); ctx.lineTo(cx + (10*this.facing), cy+10); 
        }
        else {
            ctx.moveTo(cx, cy+15); ctx.lineTo(cx - (10*this.facing), cy+30);
            ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (10*this.facing), cy+30);
        }
        
        ctx.stroke();

        if (this.shield > 0) {
            ctx.strokeStyle = "#0ff";
            ctx.beginPath(); ctx.arc(cx, cy+20, 40, 0, Math.PI*2); ctx.stroke();
        }
        
        ctx.font = "8px 'Press Start 2P'";
        ctx.fillStyle = "#fff";
        ctx.fillText(this.isPlayer ? "YOU" : (isMultiplayer ? "ENEMY" : "AI"), cx - 10, cy - 25);

        ctx.globalAlpha = 1;
    }
}

// --- VFX ---
function createFireExplosion(x, y) {
    for(let i=0; i<20; i++) {
        particles.push(new Particle(x, y, "#ff0", 12, 8, 40, true));
    }
}

// --- ABILITY LOGIC ---
function executeAbility(ent, name) {
    const dir = ent.facing;
    
    if(["Ink Shot", "Fireball", "Snipe", "Trap Shot", "Arrow", "Drone Strike"].includes(name)) {
        projectiles.push(new Projectile(ent, ent.x + (dir*30), ent.y+20, dir, name));
    }
    else if(name === "Trap") {
        projectiles.push(new Projectile(ent, ent.x, ent.y, 0, "Landmine"));
        texts.push(new FloatingText(ent.x, ent.y, "MINE SET", "#f00"));
    }
    else if(name === "Piercing Arrow") {
         projectiles.push(new Projectile(ent, ent.x + (dir*30), ent.y+20, dir, "Snipe")); 
    }
    else if(name === "Multi Shot") {
        projectiles.push(new Projectile(ent, ent.x, ent.y, dir, "Ink Shot"));
        let pUp = new Projectile(ent, ent.x, ent.y, dir, "Ink Shot"); pUp.vy = -5; projectiles.push(pUp);
        let pDown = new Projectile(ent, ent.x, ent.y, dir, "Ink Shot"); pDown.vy = 5; projectiles.push(pDown);
    }
    else if(name === "Dash Strike" || name === "Flame Dash" || name === "Quick Dash") {
        ent.vx = dir * 40;
        ent.invulnTimer = 10;
        if (name === "Flame Dash") createFireExplosion(ent.x, ent.y);
        for(let i=0; i<5; i++) particles.push(new Particle(ent.x - dir*i*10, ent.y, ent.color, 0, 30, 20));
    }
    else if(name === "Wall Jump") {
        ent.vy = -25; ent.vx = dir * 10;
    }
    else if(name === "Shadow Step" || name === "Vanish") {
        ent.invisible = true;
        setTimeout(()=> ent.invisible=false, 2000);
        ent.x += dir * 200; 
    }
    else if(name === "Backstab") {
        const target = ent.isPlayer ? enemy : player;
        ent.x = target.x - (target.facing * 50); 
        ent.y = target.y; 
        ent.facing = target.facing; 
        particles.push(new Particle(ent.x, ent.y, "#a0f", 0, 40, 20)); 
    }
    else if(["Uppercut", "Heavy Punch", "Shield Bash"].includes(name)) {
        createFireExplosion(ent.x + (dir*40), ent.y);
        if (!ent.isRemotePlayer) {
            const target = ent.isPlayer ? enemy : player;
            if(Math.abs(ent.x - target.x) < 100) {
                target.takeDamage(30, dir, 15, 40); 
                target.vy = -18; 
                if(isMultiplayer && conn) conn.send({type: 'hit_confirm', dmg: 30, dir: dir, kb: 15, stun: 40, lift: -18 });
            }
        }
    }
    else if(["Ink Burst", "Shockwave", "Ground Smash", "Inferno", "Earthquake", "Burn AoE", "Wall Smash"].includes(name)) {
        screenShake = 15;
        createFireExplosion(ent.x, ent.y);
        for(let i=0; i<30; i++) particles.push(new Particle(ent.x, ent.y, ent.color, 20, 5, 40));
        if (!ent.isRemotePlayer) {
            const target = ent.isPlayer ? enemy : player;
            const dist = Math.sqrt(Math.pow(ent.x - target.x, 2) + Math.pow(ent.y - target.y, 2));
            if(dist < 180) {
                target.takeDamage(25, dir, 20, 20);
                if(isMultiplayer && conn) conn.send({type: 'hit_confirm', dmg: 25, dir: dir, kb: 20, stun: 20 });
            }
        }
    }
    else if(name === "Rapid Strike") {
        let count = 0;
        let interval = setInterval(() => {
            if(count > 4) clearInterval(interval);
            projectiles.push(new Projectile(ent, ent.x + (ent.facing*20), ent.y + 10 + (Math.random()*20), ent.facing, "RapidHit"));
            count++;
        }, 80);
    }
    else if(name === "Heal Pulse") {
        ent.hp = Math.min(ent.hp + 40, ent.maxHp);
        texts.push(new FloatingText(ent.x, ent.y, "+40 HP", "#0f0"));
    }
    else if(name === "Barrier") {
        ent.shield = 50;
        texts.push(new FloatingText(ent.x, ent.y, "BARRIER UP", "#0ff"));
    }
    else if(name === "Taunt") {
        ent.counterActive = true;
        texts.push(new FloatingText(ent.x, ent.y - 40, "COUNTER READY", "#fff"));
        setTimeout(() => ent.counterActive = false, 1500); 
    }
    else if(name === "Afterimage") {
        particles.push(new Particle(ent.x, ent.y, ent.color, 0, 40, 60)); 
        ent.x -= dir * 100; 
    }
}

// --- GAME LOOP ---

function gameLoop() {
    ctx.save();
    if (screenShake > 0) {
        ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);
        screenShake *= 0.9;
        if(screenShake < 1) screenShake = 0;
    }
    
    bgSystem.update();
    bgSystem.draw(ctx, canvas.width, canvas.height);
    
    // --- DRAW WALLS ---
    ctx.fillStyle = "#222";
    ctx.fillRect(0, 0, WALL_THICKNESS, canvas.height); // Left Wall
    ctx.fillRect(canvas.width - WALL_THICKNESS, 0, WALL_THICKNESS, canvas.height); // Right Wall
    
    // Wall Detailing
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(WALL_THICKNESS, 0); ctx.lineTo(WALL_THICKNESS, canvas.height);
    ctx.moveTo(canvas.width - WALL_THICKNESS, 0); ctx.lineTo(canvas.width - WALL_THICKNESS, canvas.height);
    ctx.stroke();

    // --- DRAW PLATFORMS ---
    ctx.fillStyle = "#444";
    ctx.strokeStyle = "#888";
    platforms.forEach(p => {
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.strokeRect(p.x, p.y, p.w, p.h);
        // "Tech" details on platforms
        ctx.fillStyle = "#0ff";
        ctx.fillRect(p.x + 10, p.y + 5, p.w - 20, 2);
        ctx.fillStyle = "#444";
    });

    // Floor
    ctx.strokeStyle = "#fff";
    ctx.beginPath();
    ctx.moveTo(0, canvas.height-50);
    ctx.lineTo(canvas.width, canvas.height-50);
    ctx.stroke();

    if (matchActive && !player.dead && !player.melting && player.state !== "stun" && player.state !== "dash_attack" && player.state !== "rush") {
        if (keys['a']) { player.vx -= MOVE_SPEED; player.facing = -1; }
        if (keys['d']) { player.vx += MOVE_SPEED; player.facing = 1; }
        // Jump is now handled in 'keydown' event for precision
        
        if (isMultiplayer && conn) {
            conn.send({ type: 'input', keys: keys, mouse: mouse });
        }
    }

    [player, enemy].forEach(e => { e.update(); e.draw(ctx); });
    
    projectiles.forEach((p, i) => {
        p.update(); p.draw(ctx);
        if(!p.active) projectiles.splice(i, 1);
    });

    particles.forEach((p, i) => {
        p.update(); p.draw(ctx);
        if(p.life <= 0) particles.splice(i, 1);
    });
    
    texts.forEach((t, i) => {
        t.update(); t.draw(ctx);
        if(t.life <= 0) texts.splice(i, 1);
    });

    updateHUD();
    ctx.restore();
    
    if (isMultiplayer && conn && matchActive && !player.dead) {
        if (!window.frameSync) window.frameSync = 0;
        window.frameSync++;
        // INCREASED SYNC RATE: Send pos every 2 frames for 60fps smoothness
        if (window.frameSync % 2 === 0) { 
            conn.send({
                type: 'sync_pos',
                x: player.x,
                y: player.y,
                vx: player.vx,
                vy: player.vy,
                hp: player.hp
            });
        }
    }

    if(player.dead || enemy.dead) return; 
    requestAnimationFrame(gameLoop);
}

function updateHUD() {
    document.getElementById("round-display").innerText = `ROUND ${currentRound} | YOU: ${myScore} - OPP: ${enemyScore}`;

    const slots = document.getElementById("abilityGrid").children;
    for(let i=0; i<4; i++) {
        const cdVal = player.cooldowns["a"+(i+1)];
        const overlay = slots[i].querySelector(".cooldown-overlay");
        const slotDiv = slots[i];
        
        if (cdVal > 0) {
            slotDiv.classList.remove("ready");
            overlay.style.height = (cdVal / 240 * 100) + "%";
        } else {
            slotDiv.classList.add("ready");
            overlay.style.height = "0%";
        }
    }
    
    updateKeyVisual('key-q', player.cooldowns.dash, 'Q');
    updateKeyVisual('key-e', player.cooldowns.rush, 'E');
    updateKeyVisual('key-r', player.cooldowns.heavy, 'R');
    updateKeyVisual('key-f', player.cooldowns.block, 'F');
}

function updateKeyVisual(id, cd, letter) {
    const el = document.getElementById(id);
    if(cd > 0) {
        el.classList.add("cooldown");
        el.innerText = Math.ceil(cd/60); 
    } else {
        el.classList.remove("cooldown");
        el.innerText = letter;
    }
}

// --- NEW ROUND LOGIC ---

function endRound(iWon) {
    if (iWon) {
        myScore++;
        myLockedChars.push(selectedCharIndex); 
    } else {
        enemyScore++;
    }
    
    currentRound++;
    
    if (myScore >= 2 || enemyScore >= 2) {
        const finalMsg = iWon ? "CHAMPION!" : "GAME OVER";
        document.getElementById("game-message").innerText = finalMsg;
        document.getElementById("game-message").style.color = iWon ? "#0f0" : "#f00";
        setTimeout(() => location.reload(), 3000); 
    } else {
        resetToMenu();
    }
}

function resetToMenu() {
    matchActive = false;
    entities = [];
    projectiles = [];
    particles = [];
    texts = [];
    
    document.getElementById("gameContainer").style.display = "none";
    document.getElementById("menu").style.display = "flex";
    document.getElementById("game-message").style.display = "none";
    document.getElementById("health-containers").innerHTML = ""; 
    
    selectedChar = null;
    imReady = false;
    peerReady = false; // Reset peer status strictly
    
    const startBtn = document.getElementById("startBtn");
    startBtn.classList.remove("active");
    startBtn.innerText = "ENTER BATTLEGROUND";
    startBtn.style.background = "#fff";
    startBtn.style.cursor = "pointer";
    
    renderCharGrid();
    
    if(isMultiplayer) {
        netStatus.innerText = `ROUND ${currentRound} - SELECT FIGHTER`;
        netStatus.style.color = "#0ff";
    }
}

function startCountdown() {
    matchActive = false;
    let count = 3;
    
    countdownEl.style.display = "block";
    countdownEl.innerText = `ROUND ${currentRound}`;
    countdownEl.style.color = "#fff";
    
    setTimeout(() => {
        const interval = setInterval(() => {
            if(count > 0) {
                countdownEl.innerText = count;
                countdownEl.style.color = "#ff0";
            } else if (count === 0) {
                countdownEl.innerText = "FIGHT!";
                countdownEl.style.color = "#f00";
                matchActive = true;
            } else {
                clearInterval(interval);
                countdownEl.style.display = "none";
            }
            count--;
        }, 1000);
    }, 1500); 
}

function startGame(remoteCharIndex) {
    document.getElementById("menu").style.display = "none";
    document.getElementById("gameContainer").style.display = "block";
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    bgSystem.pickRandomTheme();

    // --- SETUP PLATFORMS (Battlefield Layout) ---
    platforms = [];
    const cx = canvas.width / 2;
    const cy = canvas.height - 50; // Floor height
    // Top Platform
    platforms.push({ x: cx - 60, y: cy - 250, w: 120, h: 15 });
    // Left Platform
    platforms.push({ x: cx - 220, y: cy - 130, w: 120, h: 15 });
    // Right Platform
    platforms.push({ x: cx + 100, y: cy - 130, w: 120, h: 15 });

    player = new Entity(200, 200, selectedChar.color, true, selectedChar);
    
    if(isMultiplayer) {
        const enemyChar = CHARACTERS[remoteCharIndex];
        enemy = new Entity(canvas.width - 200, 200, enemyChar.color, false, enemyChar, true);
    } else {
        const randChar = CHARACTERS[Math.floor(Math.random() * CHARACTERS.length)];
        enemy = new Entity(canvas.width - 200, 200, "#aaa", false, randChar, false);
    }
    
    entities = [player, enemy];
    
    document.getElementById("charNameDisplay").innerText = selectedChar.name;
    document.getElementById("charNameDisplay").style.color = selectedChar.color;
    
    const abGrid = document.getElementById("abilityGrid");
    abGrid.innerHTML = "";
    selectedChar.abilities.forEach((ab, i) => {
        const d = document.createElement("div");
        d.className = "ability-slot ready";
        d.innerHTML = `<div class="key">${i+1}</div><div class="name">${ab.split(" ")[0]}</div><div class="cooldown-overlay"></div>`;
        abGrid.appendChild(d);
    });
    
    updateHUD(); 
    startCountdown();
    gameLoop();
}

document.getElementById("startBtn").onclick = () => {
    if(!selectedChar) return;
    
    if (isMultiplayer) {
        imReady = true;
        document.getElementById("startBtn").innerText = "WAITING FOR OPPONENT...";
        document.getElementById("startBtn").style.background = "#555";
        document.getElementById("startBtn").style.cursor = "default";
        
        if(conn) {
             conn.send({ type: 'selected_char', index: selectedCharIndex });
        }
        
        // Wait logic: Only start if peer is ALREADY ready, otherwise wait for event
        if(peerReady) {
            startGame(peerCharIndex);
        } else {
             netStatus.innerText = "WAITING FOR OPPONENT TO SELECT...";
        }
    } else {
        startGame(0);
    }
};

window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    keys[k] = true;
    
    if (!player || player.dead || !matchActive) return;
    
    // --- DOUBLE JUMP LOGIC ---
    if (k === ' ') {
        if (player.grounded) {
            player.vy = JUMP_FORCE;
            player.grounded = false;
            player.jumps = 1;
            if(isMultiplayer) conn.send({type:'action', action:'jump'});
        } 
        else if (player.jumps < player.maxJumps) {
            player.vy = JUMP_FORCE;
            player.jumps++;
            
            // Visual for double jump
            for(let i=0; i<10; i++) particles.push(new Particle(player.x + 20, player.y + 60, "#fff", 2, 6, 20));
            
            if(isMultiplayer) conn.send({type:'action', action:'jump'});
        }
    }

    if (k === 'q') { player.performAttack("dash"); if(isMultiplayer) conn.send({type:'action', action:'dash'}); }
    if (k === 'r') { player.performAttack("heavy"); if(isMultiplayer) conn.send({type:'action', action:'heavy'}); }
    if (k === 'e') { player.performAttack("rush"); if(isMultiplayer) conn.send({type:'action', action:'rush'}); }
    if (k === 'f') { player.performAttack("block"); if(isMultiplayer) conn.send({type:'action', action:'block'}); }
    
    if (['1','2','3','4'].includes(k)) {
        player.useAbility(parseInt(k)-1);
        if(isMultiplayer) conn.send({type:'ability', index:parseInt(k)-1});
    }
});

window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
});

window.addEventListener('mousedown', () => {
    if(player && !player.dead && matchActive) {
        player.performAttack("light");
        if(isMultiplayer) conn.send({type:'action', action:'light'});
    }
});

window.addEventListener('mousemove', e => {
    mouse.x = e.clientX; mouse.y = e.clientY;
});

// --- NETWORK CONFIGURATION FOR DIFFERENT WIFI ---
// We add Google's public STUN servers to navigate through NATs/Routers
const peerConfig = {
    debug: 2,
    config: {
        'iceServers': [
            { url: 'stun:stun.l.google.com:19302' },
            { url: 'stun:stun1.l.google.com:19302' },
            { url: 'stun:stun2.l.google.com:19302' },
        ]
    }
};

if (isMultiplayer) {
    netStatus.innerText = "INITIALIZING NETWORK...";
    
    if (role === 'host') {
        peer = new Peer(roomID, peerConfig); 
    } else {
        peer = new Peer(peerConfig); 
    }

    peer.on('open', (id) => {
        console.log('My Peer ID:', id);
        
        if (role === 'host') {
            netStatus.innerText = `WAITING FOR PLAYER IN ${teamMode}...`;
            peer.on('connection', (c) => {
                conn = c;
                setupConnection();
            });
        } else {
            netStatus.innerText = "CONNECTING TO HOST...";
            conn = peer.connect(roomID);
            
            conn.on('open', () => {
                setupConnection();
            });
            
            conn.on('error', (err) => {
                console.error(err);
                netStatus.innerText = "CONNECTION FAILED - RETRY";
            });
        }
    });
    
    peer.on('error', (err) => {
        console.error(err);
        netStatus.innerText = "ERROR: " + err.type;
        alert("Connection Error. Ensure you have internet. If on corporate network, a TURN server might be needed.");
    });
}

function setupConnection() {
    netStatus.innerText = "CONNECTED! SELECT CHARACTER";
    netStatus.style.color = "#0f0";
    
    conn.on('data', (data) => {
        if (data.type === 'selected_char') {
            peerCharIndex = data.index;
            peerReady = true;
            if (imReady) {
                startGame(peerCharIndex);
            } else {
                netStatus.innerText = "OPPONENT READY! CHOOSE YOUR FIGHTER";
            }
        }
        
        if (data.type === 'input') {
            peerKeys = data.keys;
            peerMouse = data.mouse;
        }
        
        if (data.type === 'action') {
            if(!enemy) return;
            if(data.action === 'jump') {
                enemy.vy = JUMP_FORCE; // Sync Jump instantly
                for(let i=0; i<10; i++) particles.push(new Particle(enemy.x + 20, enemy.y + 60, "#fff", 2, 6, 20));
            }
            if(data.action === 'dash') enemy.performAttack("dash");
            if(data.action === 'rush') enemy.performAttack("rush");
            if(data.action === 'heavy') enemy.performAttack("heavy");
            if(data.action === 'light') enemy.performAttack("light");
            if(data.action === 'block') enemy.performAttack("block");
        }
        
        if (data.type === 'ability') {
            if(!enemy) return;
            enemy.useAbility(data.index);
        }

        if (data.type === 'hit_confirm') {
            player.takeDamage(data.dmg, data.dir, data.kb, data.stun);
            if(data.lift) player.vy = data.lift;
        }

        if (data.type === 'parry_hit') {
            player.applyStun(data.duration);
            texts.push(new FloatingText(player.x, player.y - 40, "PARRIED!", "#f00"));
        }

        if (data.type === 'sync_pos') {
            if (enemy && !enemy.dead) {
                // Better interpolation for smoothness (60% current, 40% new)
                enemy.x = enemy.x * 0.6 + data.x * 0.4;
                enemy.y = enemy.y * 0.6 + data.y * 0.4;
                enemy.hp = data.hp;
            }
        }
    });
}

</script>
</body>
</html>
