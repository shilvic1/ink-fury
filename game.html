<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Ink Fury â€” Battleground</title>
<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  body { margin:0; font-family: 'Press Start 2P', monospace; background:#000; color:#fff; overflow:hidden; user-select: none; }
  
  /* --- UI & MENUS --- */
  #menu, #gameContainer { width: 100vw; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; position: absolute; top:0; left:0; }
  #gameContainer { display: none; background: #111; }

  .logo { font-size:48px; margin-bottom:20px; border: 4px solid #fff; padding: 10px; text-shadow: 4px 4px #00f; }
  .grid { display:grid; grid-template-columns:repeat(4,160px); grid-gap:16px; }
  .card { background:#111; border:2px solid #444; padding:10px; cursor:pointer; text-align:center; transition: 0.2s; position: relative; }
  .card:hover { transform:translateY(-4px); border-color:#fff; }
  .card.selected { border-color:#0f0; box-shadow: 0 0 15px rgba(0,255,0,0.5); }
  .card .name { font-size:12px; margin-bottom:4px; color: #fff; }
  .card .role { font-size:8px; opacity:0.7; color: #aaa; }
  
  #hoverInfo { position:absolute; top:20px; right:20px; background:rgba(0,0,0,0.9); padding:15px; border: 1px solid #fff; width:250px; font-size:10px; line-height: 1.6; z-index: 10; pointer-events: none; }
  .ability-list { margin-top: 10px; color: #ccc; }
  .ability-item { margin-bottom: 4px; }
  
  #startBtn { margin-top:30px; padding:15px 40px; background:#fff; color:#000; font-family: inherit; font-size:14px; border:none; cursor:pointer; opacity:0.3; transition: 0.2s; }
  #startBtn.active { opacity:1; background: #0f0; box-shadow: 0 0 20px #0f0; }
  
  /* New Network Status UI */
  #netStatus { margin-top: 10px; font-size: 10px; color: #0ff; text-align: center; height: 20px; }

  /* --- CONTROLS HUD --- */
  #controls-hud {
    position: absolute;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.7);
    border: 1px solid #555;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 50;
    pointer-events: none;
  }
  
  .ctrl-row {
    display: flex;
    align-items: center;
    font-size: 8px;
    color: #ccc;
  }
  
  .ctrl-key {
    width: 20px;
    height: 20px;
    background: #222;
    border: 1px solid #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 10px;
    color: #ff0;
    font-size: 8px;
    box-shadow: 2px 2px #000;
    transition: 0.1s;
  }
  .ctrl-key.wide { width: 50px; }
  
  /* Cooldown Visuals for Keys */
  .ctrl-key.cooldown {
    border-color: #f00;
    color: #f00;
    background: #300;
  }

  /* --- IN-GAME HUD --- */
  canvas { background: #1a1a1a; display: block; image-rendering: pixelated; }

  #ui-hud { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); text-align: center; width: 100%; pointer-events: none; }
  #charNameDisplay { font-size: 20px; margin-bottom: 15px; letter-spacing: 2px; text-shadow: 2px 2px #000; }
  
  .ability-grid { display: flex; justify-content: center; gap: 15px; }
  .ability-slot { 
    width: 60px; height: 60px; background: rgba(0,0,0,0.8); border: 2px solid #555; 
    display: flex; flex-direction: column; align-items: center; justify-content: center; 
    font-size: 8px; position: relative; overflow: hidden; color: #fff;
  }
  .ability-slot.ready { border-color: #0ff; box-shadow: 0 0 10px #0ff; }
  .ability-slot .key { position: absolute; top: 2px; left: 2px; color: #ff0; font-size: 8px; font-weight: bold; }
  .ability-slot .name { padding: 0 4px; text-align: center; z-index: 2; }
  .cooldown-overlay { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(255, 0, 0, 0.6); transition: height 0.1s linear; z-index: 1; }

  /* Health Bars */
  #health-containers { position: absolute; top: 0; left: 0; width: 100%; height: 0; overflow: visible; }
  .hp-bar-wrap { position: absolute; width: 60px; height: 8px; background: #333; border: 1px solid #000; transform: translate(-50%, -100%); transition: top 0.1s, left 0.1s; pointer-events: none; }
  .hp-bar-fill { height: 100%; background: #0f0; width: 100%; transition: width 0.1s; }
  
  #game-message {
    position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
    font-size: 40px; color: #fff; text-shadow: 4px 4px #f00; display: none;
    z-index: 100;
  }

  /* Countdown Text */
  #countdown {
    position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
    font-size: 80px; color: #ff0; text-shadow: 5px 5px #f00; 
    display: none; z-index: 99; pointer-events: none;
  }
</style>
</head>
<body>

<div id="menu">
    <div class="logo">INK FURY</div>
    <div class="grid" id="charGrid"></div>
    <div id="hoverInfo">SELECT FIGHTER</div>
    <div id="netStatus"></div>
    <button id="startBtn">ENTER BATTLEGROUND</button>
</div>

<div id="gameContainer">
    <div id="health-containers"></div>
    <div id="controls-hud">
        <div class="ctrl-row"><div class="ctrl-key">A</div><div class="ctrl-key">D</div> MOVE</div>
        <div class="ctrl-row"><div class="ctrl-key wide">SPACE</div> JUMP</div>
        <div class="ctrl-row"><div class="ctrl-key" id="key-q">Q</div> DASH</div>
        <div class="ctrl-row"><div class="ctrl-key" id="key-e">E</div> RUSH</div>
        <div class="ctrl-row"><div class="ctrl-key" id="key-r">R</div> HEAVY</div>
        <div class="ctrl-row"><div class="ctrl-key">M1</div> ATTACK</div>
        <div class="ctrl-row"><div class="ctrl-key">1-4</div> SKILLS</div>
    </div>
    <div id="countdown">3</div>
    <div id="game-message">VICTORY</div>
    <div id="ui-hud">
        <div id="charNameDisplay">PLAYER</div>
        <div class="ability-grid" id="abilityGrid"></div>
    </div>
    <canvas id="gameCanvas"></canvas>
</div>

<script>
// --- GAME DATA ---
const CHARACTERS = [
  { 
    name:"Volt", color:"#0cf", role:"All-Rounder", 
    desc: "Fast, adaptable fighter with mobility and burst.",
    abilities:["Dash Strike","Ink Shot","Uppercut","Ink Burst"] 
  },
  { 
    name:"Flash", color:"#ff0", role:"Speed", 
    desc: "Extreme mobility and hit-and-run pressure.",
    abilities:["Quick Dash","Rapid Strike","Wall Jump","Afterimage"] 
  },
  { 
    name:"Titan", color:"#f44", role:"Strength", 
    desc: "High damage bruiser that dominates close combat.",
    abilities:["Power Slam","Ground Smash","Shockwave","Heavy Punch"] 
  },
  { 
    name:"Shade", color:"#a0f", role:"Stealth", 
    desc: "High-risk assassin specializing in surprise attacks.",
    abilities:["Vanish","Backstab","Shadow Step","Smoke Bomb"] 
  },
  { 
    name:"Gadget", color:"#5f5", role:"Utility", 
    desc: "Battlefield control and team support specialist.",
    abilities:["Trap","Barrier","Heal Pulse","Drone Strike"] 
  },
  { 
    name:"Blaze", color:"#f80", role:"Elemental", 
    desc: "Area damage mage with strong zone control.",
    abilities:["Fireball","Flame Dash","Burn AoE","Inferno"] 
  },
  { 
    name:"Arrow", color:"#fff", role:"Ranged", 
    desc: "Precision damage dealer with traps and burst.",
    abilities:["Snipe","Piercing Arrow","Trap Shot","Multi Shot"] 
  },
  { 
    name:"Anchor", color:"#840", role:"Tank", 
    desc: "Frontline protector that controls enemy movement.",
    abilities:["Shield Bash","Wall Smash","Taunt","Earthquake"] 
  },
];

// --- MENU LOGIC ---
const charGrid = document.getElementById("charGrid");
const hoverInfo = document.getElementById("hoverInfo");
const netStatus = document.getElementById("netStatus");
let selectedChar = null;

CHARACTERS.forEach((c, idx)=>{
  const card = document.createElement("div");
  card.classList.add("card");
  card.innerHTML = `<div class="name">${c.name}</div><div class="role">${c.role}</div>`;
  card.dataset.index = idx; // Store index for network syncing
  charGrid.appendChild(card);
  
  card.onmouseenter = () => {
    hoverInfo.innerHTML = `
      <b style="font-size:14px; color:${c.color}">${c.name}</b><br>
      <i style="color:#aaa">${c.role}</i><br>
      <div style="margin:10px 0; font-size:9px">${c.desc}</div>
      <div class="ability-list">
        ${c.abilities.map((a,i) => `<div class="ability-item"><span style="color:${c.color}">${i+1}.</span> ${a}</div>`).join("")}
      </div>
    `;
  };

  card.onclick = ()=>{
    // If we have already locked in (waiting for player), disable changing
    if(isMultiplayer && imReady) return;

    document.querySelectorAll(".card").forEach(x=>x.classList.remove("selected"));
    card.classList.add("selected");
    selectedChar = c;
    selectedCharIndex = idx;
    document.getElementById("startBtn").classList.add("active");
  };
});

// --- ENGINE VARIABLES ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const hpContainer = document.getElementById('health-containers');
const countdownEl = document.getElementById('countdown');

let gameLoopId;
let entities = [];
let particles = [];
let projectiles = [];
let texts = [];
let player, enemy;
let screenShake = 0;

let matchActive = false; // Prevents moving during countdown

// Input State
const keys = { w:false, a:false, s:false, d:false, shift:false, " ":false, q:false, e:false, r:false, 1:false, 2:false, 3:false, 4:false };
const mouse = { x:0, y:0, down:false };

// Physics Constants (Way Smaller Jump)
const GRAVITY = 0.9; // Higher gravity for snappiness
const FRICTION = 0.88; 
const JUMP_FORCE = -9.5; // Very small "short hop"
const MOVE_SPEED = 0.8; 

// --- NETWORK VARIABLES (Added) ---
const urlParams = new URLSearchParams(window.location.search);
const gameMode = urlParams.get('mode') || 'vsai'; 
const roomID = urlParams.get('room');
const role = urlParams.get('role'); // host or join
const teamMode = urlParams.get('team') || '1v1';
const username = urlParams.get('user') || 'Player';

let isMultiplayer = (gameMode === 'online');
let peer = null;
let conn = null;
let imReady = false;
let peerReady = false;
let selectedCharIndex = 0;
let peerCharIndex = 0; // The index of the char the opponent picked
let peerKeys = {}; // Stores inputs received from opponent
let peerMouse = { x:0, y:0 };

// --- CLASSES ---

class Particle {
    constructor(x, y, color, speed, size, life, isFire = false) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.color = color;
        this.size = size;
        this.life = life;
        this.maxLife = life;
        this.isFire = isFire;
        if(isFire) {
             this.vy = -Math.random() * 2 - 1; // Float up
        }
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.size *= 0.95;
        
        if (this.isFire) {
            // Shift color yellow -> red -> dark
            const r = 255;
            const g = Math.floor((this.life/this.maxLife) * 200);
            this.color = `rgb(${r}, ${g}, 0)`;
        }
    }
    draw(ctx) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

class FloatingText {
    constructor(x, y, text, color) {
        this.x = x; this.y = y;
        this.text = text;
        this.color = color;
        this.life = 60;
        this.vy = -1;
    }
    update() {
        this.y += this.vy;
        this.life--;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life / 60);
        ctx.fillStyle = this.color;
        ctx.font = "10px 'Press Start 2P'";
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
    }
}

class Projectile {
    constructor(owner, x, y, dir, type) {
        this.owner = owner;
        this.x = x; this.y = y;
        this.w = 20; this.h = 20;
        this.dir = dir;
        this.type = type;
        this.life = 100;
        this.active = true;
        this.vx = dir * 15;
        this.vy = 0;
        this.color = owner.color;
        
        // Custom projectile logic
        if(type === "Ink Shot") { this.vx = dir * 18; this.dmg = 15; }
        else if(type === "Fireball") { this.vx = dir * 12; this.w = 30; this.h = 30; this.dmg = 20; this.color = "#f80"; }
        else if(type === "Snipe") { this.vx = dir * 30; this.w = 40; this.h = 5; this.dmg = 35; }
        else if(type === "RapidHit") { this.vx = dir * 20; this.w = 15; this.h = 15; this.dmg = 6; this.life = 10; }
        else if(type === "Trap Shot") { this.vx = dir * 12; this.dmg = 5; this.effect = "slow"; }
        else { this.dmg = 10; }
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        if(this.life <= 0) this.active = false;
        
        // Particles
        if(Math.random() > 0.5) particles.push(new Particle(this.x, this.y, this.color, 5, 4, 20, this.type === "Fireball"));

        // Collision
        entities.forEach(e => {
            // SYNC CHANGE: Only the owner of the projectile calculates the hit.
            // If I didn't shoot this, I wait for the network to tell me I got hit.
            if (isMultiplayer && this.owner.isRemotePlayer) return;

            if (e !== this.owner && !e.dead) {
                if (this.x < e.x + e.w && this.x + this.w > e.x &&
                    this.y < e.y + e.h && this.y + this.h > e.y) {
                    
                    e.takeDamage(this.dmg, this.dir, 5);
                    if(this.effect === "slow") e.applyStatus("slow", 120);
                    if(this.type === "Fireball") createFireExplosion(this.x, this.y);
                    
                    // --- SYNC SEND: TELL NETWORK WE HIT THE ENEMY ---
                    if (isMultiplayer && conn && e.isRemotePlayer) {
                        conn.send({
                            type: 'hit_confirm',
                            dmg: this.dmg,
                            dir: this.dir,
                            kb: 5,
                            stun: 0
                        });
                    }

                    this.active = false;
                    for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, this.color, 10, 5, 30));
                }
            }
        });
    }
    
    draw(ctx) {
        ctx.fillStyle = this.color;
        if (this.type === "Snipe") ctx.fillRect(this.x, this.y, this.w, this.h);
        else ctx.beginPath(), ctx.arc(this.x+this.w/2, this.y+this.h/2, this.w/2, 0, Math.PI*2), ctx.fill();
    }
}

class Entity {
    constructor(x, y, color, isPlayer, charData, isRemotePlayer = false) {
        this.x = x; this.y = y;
        this.w = 40; this.h = 70;
        this.color = color;
        this.isPlayer = isPlayer;
        this.isRemotePlayer = isRemotePlayer; // New flag for multiplayer enemy
        this.charData = charData; 
        this.maxHp = 200;
        this.hp = 200;
        
        this.vx = 0; this.vy = 0;
        this.facing = 1; 
        
        this.grounded = false;
        this.jumps = 0;
        this.isDashing = false;
        
        // Timers
        this.dashTimer = 0;
        this.rushTimer = 0;
        
        // Combat States
        this.state = "idle"; 
        this.attackTimer = 0;
        this.attackType = "light";
        this.counterActive = false; // For Taunt Counter
        
        // Cooldowns
        this.cooldowns = { heavy: 0, dash: 0, rush: 0, a1: 0, a2: 0, a3: 0, a4: 0 };
        this.invulnTimer = 0;
        this.dead = false;
        
        // Status
        this.invisible = false;
        this.shield = 0;
        this.speedMod = 1;
        
        // Create HP Bar element
        this.hpBar = document.createElement('div');
        this.hpBar.className = "hp-bar-wrap";
        this.hpBar.innerHTML = `<div class="hp-bar-fill"></div>`;
        hpContainer.appendChild(this.hpBar);

        // --- MELT VARIABLES ---
        this.melting = false;
        this.meltTimer = 1.0; // 1.0 = full size, 0.0 = puddle
    }

    update() {
        if (this.dead) return;
        
        // --- MELT LOGIC ---
        if (this.melting) {
            this.meltTimer -= 0.015; // Speed of melt
            
            // Spawn dripping particles
            if(Math.random() > 0.3) {
                particles.push(new Particle(
                    this.x + (Math.random() * this.w * (2 - this.meltTimer)) - 10, // Random width
                    this.y + this.h, 
                    this.color, 
                    2, 4, 30
                ));
            }

            // When melt is finished, trigger the actual Game Over state
            if (this.meltTimer <= 0) {
                this.meltTimer = 0;
                this.dead = true; // Now the loop stops
                
                // Show Victory/Defeat UI (Moved from old die function)
                if(!this.isPlayer) {
                     document.getElementById("game-message").innerText = "VICTORY";
                     document.getElementById("game-message").style.display = "block";
                } else {
                     document.getElementById("game-message").innerText = "DEFEAT";
                     document.getElementById("game-message").style.display = "block";
                     document.getElementById("game-message").style.color = "#f00";
                }
                setTimeout(() => location.reload(), 3000);
            }
            return; // Skip normal physics while melting
        }
        
        // --- MULTIPLAYER INPUT SYNC FOR REMOTE ENEMY ---
        if (isMultiplayer && this.isRemotePlayer && matchActive) {
            this.handleRemoteInput();
        }

        // Apply Gravity only if not Rushing
        if (this.state !== "rush") {
            this.vy += GRAVITY;
        }

        this.vx *= FRICTION;
        
        // Apply Velocity
        this.x += this.vx * this.speedMod;
        this.y += this.vy;

        // Ground Collision
        if (this.y + this.h > canvas.height - 50) {
            this.y = canvas.height - 50 - this.h;
            
            // Ground Slam Impact
            if (this.state === "attack" && this.attackType === "down_slam" && this.vy > 10) {
                 screenShake = 15;
                 createFireExplosion(this.x + this.w/2, this.y + this.h);
                 this.state = "idle"; // Cancel anim on land
            }

            if(this.state !== "rush") {
                this.vy = 0;
                this.grounded = true;
                this.jumps = 0;
            }
        } else {
            this.grounded = false;
        }
        
        // Screen Bounds
        if(this.x < 0) this.x = 0;
        if(this.x > canvas.width - this.w) this.x = canvas.width - this.w;

        // Update Timers
        this.invulnTimer--;
        for(let k in this.cooldowns) if(this.cooldowns[k] > 0) this.cooldowns[k]--;
        
        // State Machine
        if (this.state === "stun") {
            this.attackTimer--;
            if (this.attackTimer <= 0) this.state = "idle";
        } 
        else if (this.state === "attack") {
            this.attackTimer--;
            if (this.attackTimer === 5 || this.attackTimer === 35 || this.attackTimer === 2) this.spawnHitbox(); 
            if (this.attackTimer <= 0) this.state = "idle";
        }
        else if (this.state === "dash_attack") {
            this.dashTimer--;
            this.vx = this.facing * 25; // High speed dash
            this.vy = 0; // Gravity defy
            
            // Trail
            if(this.dashTimer % 2 === 0) particles.push(new Particle(this.x, this.y, this.color, 0, 40, 10)); 

            if (this.dashTimer <= 0) {
                this.vx = 0;
                this.performAttack("dash_finisher");
            }
        }
        else if (this.state === "rush") {
            this.rushTimer--;
            // Trail
            particles.push(new Particle(this.x, this.y, "#0ff", 0, 30, 10));
            
            // Hit detection during rush
            const target = this.isPlayer ? enemy : player;
            
            // SYNC CHECK: Rush collision should only happen if I am the rusher
            if (!this.isRemotePlayer) { 
                if (this.x < target.x + target.w && this.x + this.w > target.x &&
                    this.y < target.y + target.h && this.y + this.h > target.y) {
                        // Hit!
                        target.takeDamage(20, this.facing, 10, 20);
                        this.state = "idle";
                        this.vx = -this.facing * 5; // Bounce back
                        this.vy = -5;
                        createFireExplosion(target.x, target.y);

                        // SYNC: Send hit
                        if(isMultiplayer && conn) {
                            conn.send({ type: 'hit_confirm', dmg: 20, dir: this.facing, kb: 10, stun: 20 });
                        }
                }
            }

            if (this.rushTimer <= 0) {
                this.state = "idle";
                this.vx = this.vx * 0.2; // Slow down
            }
        }
        
        // UI Update
        const fill = this.hpBar.querySelector('.hp-bar-fill');
        fill.style.width = (this.hp / this.maxHp * 100) + "%";
        this.hpBar.style.left = (this.x + this.w/2) + "px";
        this.hpBar.style.top = (this.y - 10) + "px";
        
        // AI Logic - DISABLED IN MULTIPLAYER
        if (!this.isPlayer && !this.isRemotePlayer && matchActive) this.aiLogic();
    }

    handleRemoteInput() {
        if(this.state === "stun" || this.state === "dash_attack" || this.state === "rush") return;
        
        // Movement based on synced keys
        if (peerKeys['a']) { this.vx -= MOVE_SPEED; this.facing = -1; }
        if (peerKeys['d']) { this.vx += MOVE_SPEED; this.facing = 1; }
        
        if (peerKeys[' '] && this.grounded) { 
            this.vy = JUMP_FORCE; this.grounded = false; 
        }

        // Attacks
        // Note: We use flags sent from the peer. 
        // Logic handled in message listener usually triggers functions directly, 
        // but simple movement is better smoothed here.
    }

    aiLogic() {
        if(this.state === "stun" || this.state === "attack" || this.state === "dash_attack" || this.state === "rush") return;
        
        const target = player;
        const dist = Math.abs(target.x - this.x);
        const yDist = target.y - this.y;

        // Face player
        this.facing = (target.x - this.x) > 0 ? 1 : -1;

        // AI Rush Usage
        if (dist > 250 && Math.random() < 0.02 && this.cooldowns.rush <= 0) {
             this.performAttack("rush");
             return;
        }

        // VOLT PLAYSTYLE (Aggressive / Combo / Aerial)
        
        // 1. If opponent is in the air above me -> Jump & Uppercut
        if (yDist < -50 && dist < 50 && this.grounded) {
             this.vy = JUMP_FORCE;
             setTimeout(() => this.performAttack("light"), 100); // Trigger uppercut mid-air
             return;
        }

        // 2. Dash to close distance
        if (dist > 200 && this.cooldowns.dash <= 0) {
            this.performAttack("dash");
            return;
        }

        // 3. Close Range Combat
        if (dist < 70) {
            // Chance to use heavy if not on cooldown
            if (this.cooldowns.heavy <= 0 && Math.random() < 0.05) {
                this.performAttack("heavy");
            } 
            // Standard combo mixing
            else if (Math.random() < 0.1) {
                this.performAttack("light");
            }
        } else {
            // Chase
            this.vx += this.facing * MOVE_SPEED;
            // Jump over player or obstacles
            if (this.grounded && Math.random() < 0.02) this.vy = JUMP_FORCE;
        }
        
        // 4. Random Ability Usage
        if (Math.random() < 0.01) {
            const r = Math.floor(Math.random()*4);
            this.useAbility(r);
        }
    }

    performAttack(type, targetMouse) {
        if (this.state === "stun" || this.state === "attack" || this.state === "dash_attack" || this.state === "rush") return;

        // Determine specific Light Attack Variations
        // DOWN SLAM LOGIC: If falling (vy > 0) and not grounded, trigger slam
        if (type === "light") {
            if (!this.grounded) {
                if (this.vy < 0) type = "uppercut";
                else if (this.vy > 0) type = "down_slam";
            }
        }

        if (type === "light") {
            this.state = "attack";
            this.attackTimer = 20; // Slower
            this.attackType = "light";
        }
        else if (type === "uppercut") {
            this.state = "attack";
            this.attackTimer = 25;
            this.attackType = "uppercut";
            texts.push(new FloatingText(this.x, this.y - 30, "UPPERCUT!", "#ff0"));
        }
        else if (type === "down_slam") {
            this.state = "attack";
            this.attackTimer = 25;
            this.attackType = "down_slam";
            this.vy = 25; // FORCE DOWNWARD SLAM VELOCITY
            texts.push(new FloatingText(this.x, this.y - 30, "SLAM!", "#f44"));
        }
        else if (type === "heavy") {
            // For multiplayer sync, we might skip cooldown check on receiver side,
            // but keeping it is fine as long as we don't desync.
            // Better to force it if remote.
            if (this.cooldowns.heavy > 0 && !this.isRemotePlayer) return;
            this.cooldowns.heavy = 300; 
            this.state = "attack";
            this.attackTimer = 50; // Long windup
            this.attackType = "heavy";
            texts.push(new FloatingText(this.x, this.y-20, "CHARGING!", "#f00"));
        } 
        else if (type === "dash") {
            if (this.cooldowns.dash > 0 && !this.isRemotePlayer) return;
            this.cooldowns.dash = 180;
            this.state = "dash_attack";
            this.dashTimer = 10; 
        }
        else if (type === "dash_finisher") {
            this.state = "attack";
            this.attackTimer = 15;
            this.attackType = "dash_hit";
        }
        else if (type === "rush") {
            if(this.cooldowns.rush > 0 && !this.isRemotePlayer) return;
            this.cooldowns.rush = 300; // 5 seconds
            this.state = "rush";
            this.rushTimer = 15;
            
            // Calculate Vector to Mouse
            let targetX, targetY;
            
            if (this.isPlayer) {
                targetX = mouse.x;
                targetY = mouse.y;
            } else if (this.isRemotePlayer) {
                // Use Synced Mouse
                targetX = peerMouse.x;
                targetY = peerMouse.y;
            } else {
                // AI aims at player
                targetX = player.x;
                targetY = player.y;
            }
            
            const dx = targetX - (this.x + this.w/2);
            const dy = targetY - (this.y + this.h/2);
            const angle = Math.atan2(dy, dx);
            
            this.facing = dx > 0 ? 1 : -1;
            
            // Rush Velocity
            const speed = 30;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            
            texts.push(new FloatingText(this.x, this.y-40, "RUSH!", "#0ff"));
        }
    }

    useAbility(index) {
        if (!matchActive) return;
        if (this.state !== "idle" && this.state !== "run" && this.state !== "jump") return;
        const key = "a"+(index+1);
        if (this.cooldowns[key] > 0 && !this.isRemotePlayer) return;
        
        const abilityName = this.charData.abilities[index];
        this.cooldowns[key] = 240; 
        
        texts.push(new FloatingText(this.x, this.y-40, abilityName.toUpperCase(), "#fff"));
        executeAbility(this, abilityName);
    }

    spawnHitbox() {
        let dmg = 0, kb = 0, stun = 0, range = 0, h = 0, yOffset = 0;
        let lift = -5;
        let isHeavy = false;
        
        // Attack Data
        if (this.attackType === "light") {
            dmg = 10; kb = 5; stun = 15; range = 50; h = 40; yOffset = 20;
        } 
        else if (this.attackType === "uppercut") {
            dmg = 15; kb = 2; lift = -18; stun = 30; range = 40; h = 60; yOffset = 0;
        }
        else if (this.attackType === "down_slam") {
            dmg = 18; kb = 5; lift = 15; stun = 30; range = 45; h = 60; yOffset = 30;
            // Additional Slam Effect
            screenShake = 10;
        }
        else if (this.attackType === "heavy") {
            if(this.attackTimer !== 5) return; // Hit only at end
            dmg = 45; kb = 25; stun = 60; range = 80; h = 70; yOffset = 20; isHeavy = true;
            screenShake = 15;
            createFireExplosion(this.x + (this.facing*50), this.y+20);
        } 
        else if (this.attackType === "dash_hit") {
            dmg = 25; kb = 10; stun = 30; range = 60; h = 50; yOffset = 20;
        }

        const target = this.isPlayer ? enemy : player;
        
        // SYNC CHANGE: Only check hitbox if I am hitting the enemy
        // If I am the remote player (enemy ghost), I don't calculate hits, I wait for network.
        if (this.isRemotePlayer) return; 

        const hitX = this.facing === 1 ? this.x + this.w : this.x - range;
        const hitY = this.y + yOffset;
        
        if (hitX < target.x + target.w && hitX + range > target.x &&
            hitY < target.y + target.h && hitY + h > target.y) {
            
            target.takeDamage(dmg, this.facing, kb, stun);
            target.vy = lift; // Apply vertical force
            
            // --- SYNC SEND: WE HIT THEM ---
            if (isMultiplayer && conn) {
                conn.send({
                    type: 'hit_confirm',
                    dmg: dmg,
                    dir: this.facing,
                    kb: kb,
                    stun: stun,
                    lift: lift
                });
            }

            // Visuals
            for(let i=0; i<5; i++) particles.push(new Particle(hitX, hitY, "#fff", 5, 3, 10));
        }
    }

    takeDamage(amount, dir, knockback, stunFrames = 0) {
        // --- COUNTER LOGIC (TAUNT) ---
        if (this.counterActive) {
            texts.push(new FloatingText(this.x, this.y - 40, "COUNTER!", "#fff"));
            this.counterActive = false; // Consume counter
            
            // Reflect Damage
            if (!this.isRemotePlayer) {
                 const attacker = this.isPlayer ? enemy : player;
                 attacker.takeDamage(amount * 1.5, -dir, 15, 40); // Knockback attacker
                 if(isMultiplayer && conn) {
                     conn.send({ type: 'hit_confirm', dmg: amount*1.5, dir: -dir, kb: 15, stun: 40 });
                 }
            }
            return; // Negate damage
        }

        if (this.invulnTimer > 0 || this.dead || this.shield > amount) {
             if(this.shield > 0) { this.shield -= amount; texts.push(new FloatingText(this.x, this.y, "BLOCKED", "#0ff")); }
             return;
        }

        this.hp -= amount;
        this.invulnTimer = 15;
        this.vx = dir * knockback;
        
        // Stagger/Stun
        if (stunFrames > 0) {
            this.state = "stun";
            this.attackTimer = stunFrames; 
        }
        
        screenShake = 5;
        texts.push(new FloatingText(this.x, this.y, "-" + amount, "#f00"));
        for(let i=0; i<8; i++) particles.push(new Particle(this.x+this.w/2, this.y+this.h/2, "#f00", 6, 4, 30));

        if (this.hp <= 0) {
            this.die();
        }
    }
    
    applyStatus(type, duration) {
        if(type === "slow") { this.speedMod = 0.5; setTimeout(()=> this.speedMod=1, duration*16); }
    }

    die() {
        // If already melting or dead, don't trigger again
        if (this.dead || this.melting) return;

        // Start the melt
        this.melting = true; 
        this.hp = 0;
        this.hpBar.style.display = 'none';
        
        // Initial blood/ink explosion
        for(let i=0; i<30; i++) particles.push(new Particle(this.x, this.y, this.color, 15, 6, 60));
        
        // We do NOT set this.dead = true yet. 
        // We wait for the update() function to finish the melt animation first.
    }

    draw(ctx) {
        if (this.invisible) ctx.globalAlpha = 0.2;

        // --- MELT RENDER ---
        if (this.melting) {
            ctx.fillStyle = this.color;
            
            // Calculate squash and stretch dimensions
            const currentH = this.h * this.meltTimer;
            const currentW = this.w * (1 + (1 - this.meltTimer) * 2); // Gets 3x wider
            const xOffset = (currentW - this.w) / 2;
            const yOffset = this.h - currentH; // Keep feet on floor

            // Draw the melting puddle
            ctx.beginPath();
            // Draw a rounded rect/oval shape for the puddle
            ctx.ellipse(
                this.x + this.w/2, 
                this.y + yOffset + currentH, 
                currentW/2, 
                currentH, 
                0, Math.PI, 0 // Half oval
            );
            ctx.fill();
            
            // Draw eyes sinking (optional detail)
            if (this.meltTimer > 0.3) {
                ctx.fillStyle = "#000";
                ctx.fillRect(this.x + 10, this.y + yOffset + 10, 5, 5);
                ctx.fillRect(this.x + 25, this.y + yOffset + 10, 5, 5);
            }
            
            ctx.globalAlpha = 1;
            return; // Stop drawing the normal stick figure
        }
        
        ctx.strokeStyle = this.state === "stun" ? "#555" : this.color;
        
        // Counter Stance Visual
        if (this.counterActive) ctx.strokeStyle = "#fff"; 
        
        if (this.invulnTimer > 0 && Math.floor(Date.now()/50)%2===0) ctx.strokeStyle = "transparent";
        
        ctx.lineWidth = 4;
        const cx = this.x + this.w/2;
        const cy = this.y + 20;

        ctx.beginPath();
        
        // Head
        ctx.arc(cx, cy, 10, 0, Math.PI*2);
        
        // Body
        ctx.moveTo(cx, cy+10); ctx.lineTo(cx, cy+40);
        
        // Legs (Simple animation)
        if(Math.abs(this.vx) > 1 && this.grounded) {
             ctx.moveTo(cx, cy+40); ctx.lineTo(cx-10 + Math.sin(Date.now()/100)*10, cy+70);
             ctx.moveTo(cx, cy+40); ctx.lineTo(cx+10 - Math.sin(Date.now()/100)*10, cy+70);
        } else {
             ctx.moveTo(cx, cy+40); ctx.lineTo(cx-10, cy+70);
             ctx.moveTo(cx, cy+40); ctx.lineTo(cx+10, cy+70);
        }

        // Arms - Animation Logic
        if (this.state === "attack") {
            if(this.attackType === "heavy") {
                 // Overhead swing
                 const progress = 1 - (this.attackTimer / 50);
                 const angle = (Math.PI) * progress;
                 ctx.moveTo(cx, cy+15); 
                 ctx.lineTo(cx + (30*this.facing), cy + 15 + (Math.sin(angle)*20));
            } else if (this.attackType === "uppercut") {
                 ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (15*this.facing), cy-15);
            } else if (this.attackType === "down_slam") {
                 ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (15*this.facing), cy+40);
            } else {
                 // Jab
                 ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (25*this.facing), cy+20);
            }
        } 
        else if (this.state === "rush") {
            // Naruto run arms
            ctx.moveTo(cx, cy+15); ctx.lineTo(cx - (20*this.facing), cy+10);
        }
        else if (this.counterActive) {
            // Blocking pose
            ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (15*this.facing), cy+10);
            ctx.moveTo(cx + (15*this.facing), cy+10); ctx.lineTo(cx + (15*this.facing), cy+30);
        }
        else {
            // Idle arms
            ctx.moveTo(cx, cy+15); ctx.lineTo(cx - (10*this.facing), cy+30);
            ctx.moveTo(cx, cy+15); ctx.lineTo(cx + (10*this.facing), cy+30);
        }
        
        ctx.stroke();

        if (this.shield > 0) {
            ctx.strokeStyle = "#0ff";
            ctx.beginPath(); ctx.arc(cx, cy+20, 40, 0, Math.PI*2); ctx.stroke();
        }
        
        // Name Tag
        ctx.font = "8px 'Press Start 2P'";
        ctx.fillStyle = "#fff";
        ctx.fillText(this.isPlayer ? "YOU" : (isMultiplayer ? "ENEMY" : "AI"), cx - 10, cy - 25);

        ctx.globalAlpha = 1;
    }
}

// --- VFX ---
function createFireExplosion(x, y) {
    for(let i=0; i<20; i++) {
        particles.push(new Particle(x, y, "#ff0", 12, 8, 40, true));
    }
}

// --- ABILITY LOGIC ---
function executeAbility(ent, name) {
    const dir = ent.facing;
    
    // PROJECTILES
    if(["Ink Shot", "Fireball", "Snipe", "Trap Shot", "Arrow", "Drone Strike"].includes(name)) {
        projectiles.push(new Projectile(ent, ent.x + (dir*30), ent.y+20, dir, name));
    }
    else if(name === "Piercing Arrow") {
         projectiles.push(new Projectile(ent, ent.x + (dir*30), ent.y+20, dir, "Snipe")); 
    }
    else if(name === "Multi Shot") {
        projectiles.push(new Projectile(ent, ent.x, ent.y, dir, "Ink Shot"));
        let pUp = new Projectile(ent, ent.x, ent.y, dir, "Ink Shot"); pUp.vy = -5; projectiles.push(pUp);
        let pDown = new Projectile(ent, ent.x, ent.y, dir, "Ink Shot"); pDown.vy = 5; projectiles.push(pDown);
    }
    
    // DASHES / MOVEMENT
    else if(name === "Dash Strike" || name === "Flame Dash" || name === "Quick Dash") {
        ent.vx = dir * 40;
        ent.invulnTimer = 10;
        if (name === "Flame Dash") createFireExplosion(ent.x, ent.y);
        for(let i=0; i<5; i++) particles.push(new Particle(ent.x - dir*i*10, ent.y, ent.color, 0, 30, 20));
    }
    else if(name === "Wall Jump") {
        ent.vy = -25; ent.vx = dir * 10;
    }
    else if(name === "Shadow Step" || name === "Vanish") {
        ent.invisible = true;
        setTimeout(()=> ent.invisible=false, 2000);
        ent.x += dir * 200; // Teleport
    }
    else if(name === "Backstab") {
        const target = ent.isPlayer ? enemy : player;
        ent.x = target.x - (target.facing * 50); // Teleport behind
        ent.y = target.y; 
        ent.facing = target.facing; // Match direction to face their back
        particles.push(new Particle(ent.x, ent.y, "#a0f", 0, 40, 20)); // Poof effect
    }
    
    // AOE / MELEE SPECIALS
    else if(["Uppercut", "Heavy Punch", "Shield Bash"].includes(name)) {
        createFireExplosion(ent.x + (dir*40), ent.y);
        
        // SYNC: Only calculate AOE hits if I am the source
        if (!ent.isRemotePlayer) {
            const target = ent.isPlayer ? enemy : player;
            if(Math.abs(ent.x - target.x) < 100) {
                target.takeDamage(30, dir, 15, 40); 
                target.vy = -18; // Launch up
                if(isMultiplayer && conn) conn.send({type: 'hit_confirm', dmg: 30, dir: dir, kb: 15, stun: 40, lift: -18 });
            }
        }
    }
    // Added Wall Smash and Earthquake to AoE list
    else if(["Ink Burst", "Shockwave", "Ground Smash", "Inferno", "Earthquake", "Burn AoE", "Wall Smash"].includes(name)) {
        screenShake = 15;
        createFireExplosion(ent.x, ent.y);
        for(let i=0; i<30; i++) particles.push(new Particle(ent.x, ent.y, ent.color, 20, 5, 40));

        // SYNC: Only calculate AOE hits if I am the source
        if (!ent.isRemotePlayer) {
            const target = ent.isPlayer ? enemy : player;
            const dist = Math.sqrt(Math.pow(ent.x - target.x, 2) + Math.pow(ent.y - target.y, 2));
            if(dist < 180) {
                target.takeDamage(25, dir, 20, 20);
                if(isMultiplayer && conn) conn.send({type: 'hit_confirm', dmg: 25, dir: dir, kb: 20, stun: 20 });
            }
        }
    }
    
    // SPECIAL MECHANICS
    else if(name === "Rapid Strike") {
        // Fire bursts of short range mini hits
        let count = 0;
        let interval = setInterval(() => {
            if(count > 4) clearInterval(interval);
            projectiles.push(new Projectile(ent, ent.x + (ent.facing*20), ent.y + 10 + (Math.random()*20), ent.facing, "RapidHit"));
            count++;
        }, 80);
    }
    
    // UTILITY
    else if(name === "Heal Pulse") {
        ent.hp = Math.min(ent.hp + 40, ent.maxHp);
        texts.push(new FloatingText(ent.x, ent.y, "+40 HP", "#0f0"));
    }
    else if(name === "Barrier") {
        ent.shield = 50;
    }
    else if(name === "Taunt") {
        // Counter Stance
        ent.counterActive = true;
        texts.push(new FloatingText(ent.x, ent.y - 40, "COUNTER READY", "#fff"));
        setTimeout(() => ent.counterActive = false, 1500); // 1.5s window
    }
    else if(name === "Afterimage") {
        particles.push(new Particle(ent.x, ent.y, ent.color, 0, 40, 60)); 
        ent.x -= dir * 100; 
    }
}

// --- GAME LOOP ---

function gameLoop() {
    // 1. Clear & Shake
    ctx.save();
    if (screenShake > 0) {
        ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);
        screenShake *= 0.9;
        if(screenShake < 1) screenShake = 0;
    }
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(-10, -10, canvas.width+20, canvas.height+20);
    
    // Floor
    ctx.strokeStyle = "#fff";
    ctx.beginPath();
    ctx.moveTo(0, canvas.height-50);
    ctx.lineTo(canvas.width, canvas.height-50);
    ctx.stroke();

    // 2. Input Handling (Player)
    if (matchActive && !player.dead && !player.melting && player.state !== "stun" && player.state !== "dash_attack" && player.state !== "rush") {
        // Move
        if (keys['a']) { player.vx -= MOVE_SPEED; player.facing = -1; }
        if (keys['d']) { player.vx += MOVE_SPEED; player.facing = 1; }
        
        // Jump
        if (keys[' '] && player.grounded) { 
            player.vy = JUMP_FORCE; player.grounded = false; 
        }
        
        // --- MULTIPLAYER SYNC ---
        if (isMultiplayer && conn) {
            conn.send({ type: 'input', keys: keys, mouse: mouse });
        }
    }

    // 3. Updates & Draws
    [player, enemy].forEach(e => { e.update(); e.draw(ctx); });
    
    projectiles.forEach((p, i) => {
        p.update(); p.draw(ctx);
        if(!p.active) projectiles.splice(i, 1);
    });

    particles.forEach((p, i) => {
        p.update(); p.draw(ctx);
        if(p.life <= 0) particles.splice(i, 1);
    });
    
    texts.forEach((t, i) => {
        t.update(); t.draw(ctx);
        if(t.life <= 0) texts.splice(i, 1);
    });

    updateHUD();
    ctx.restore();
    
    // --- SYNC UPDATE: SEND POSITION ---
    // Every 10 frames, ensure our position is accurate on the other screen
    if (isMultiplayer && conn && matchActive && !player.dead) {
        if (!window.frameSync) window.frameSync = 0;
        window.frameSync++;
        if (window.frameSync % 10 === 0) {
            conn.send({
                type: 'sync_pos',
                x: player.x,
                y: player.y,
                hp: player.hp
            });
        }
    }

    if(player.dead || enemy.dead) return; 
    requestAnimationFrame(gameLoop);
}

function updateHUD() {
    // Update Ability Icons
    const slots = document.getElementById("abilityGrid").children;
    for(let i=0; i<4; i++) {
        const cdVal = player.cooldowns["a"+(i+1)];
        const overlay = slots[i].querySelector(".cooldown-overlay");
        const slotDiv = slots[i];
        
        if (cdVal > 0) {
            slotDiv.classList.remove("ready");
            overlay.style.height = (cdVal / 240 * 100) + "%";
        } else {
            slotDiv.classList.add("ready");
            overlay.style.height = "0%";
        }
    }
    
    // Update Control Keys Visuals (Q, E, R)
    updateKeyVisual('key-q', player.cooldowns.dash, 'Q');
    updateKeyVisual('key-e', player.cooldowns.rush, 'E');
    updateKeyVisual('key-r', player.cooldowns.heavy, 'R');
}

function updateKeyVisual(id, cd, letter) {
    const el = document.getElementById(id);
    if(cd > 0) {
        el.classList.add("cooldown");
        el.innerText = Math.ceil(cd/60); // Show seconds
    } else {
        el.classList.remove("cooldown");
        el.innerText = letter;
    }
}

function startCountdown() {
    matchActive = false;
    let count = 3;
    countdownEl.style.display = "block";
    countdownEl.innerText = count;
    
    const interval = setInterval(() => {
        count--;
        if(count > 0) {
            countdownEl.innerText = count;
        } else if (count === 0) {
            countdownEl.innerText = "FIGHT!";
            countdownEl.style.color = "#f00";
            matchActive = true;
        } else {
            clearInterval(interval);
            countdownEl.style.display = "none";
        }
    }, 1000);
}

function startGame(remoteCharIndex) {
    document.getElementById("menu").style.display = "none";
    document.getElementById("gameContainer").style.display = "block";
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Init My Player
    player = new Entity(200, 200, selectedChar.color, true, selectedChar);
    
    // Init Enemy
    if(isMultiplayer) {
        // Use the character the peer selected
        const enemyChar = CHARACTERS[remoteCharIndex];
        enemy = new Entity(canvas.width - 200, 200, enemyChar.color, false, enemyChar, true);
    } else {
        // VS AI: Random Enemy
        const randChar = CHARACTERS[Math.floor(Math.random() * CHARACTERS.length)];
        enemy = new Entity(canvas.width - 200, 200, "#aaa", false, randChar, false);
    }
    
    entities = [player, enemy];
    
    // Init HUD
    document.getElementById("charNameDisplay").innerText = selectedChar.name;
    document.getElementById("charNameDisplay").style.color = selectedChar.color;
    
    const abGrid = document.getElementById("abilityGrid");
    abGrid.innerHTML = "";
    selectedChar.abilities.forEach((ab, i) => {
        const d = document.createElement("div");
        d.className = "ability-slot ready";
        d.innerHTML = `<div class="key">${i+1}</div><div class="name">${ab.split(" ")[0]}</div><div class="cooldown-overlay"></div>`;
        abGrid.appendChild(d);
    });
    
    startCountdown();
    gameLoop();
}

document.getElementById("startBtn").onclick = () => {
    if(!selectedChar) return;
    
    if (isMultiplayer) {
        // In multiplayer, button means "Ready"
        imReady = true;
        document.getElementById("startBtn").innerText = "WAITING FOR OPPONENT...";
        document.getElementById("startBtn").style.background = "#555";
        document.getElementById("startBtn").style.cursor = "default";
        
        // Send choice to peer
        if(conn) {
             conn.send({ type: 'selected_char', index: selectedCharIndex });
        }
        
        // If peer already ready (received their packet earlier), start
        if(peerReady) {
            startGame(peerCharIndex);
        }
    } else {
        // Single player - Immediate Start
        startGame(0);
    }
};

// --- EVENTS ---

window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    keys[k] = true;
    
    if (!player || player.dead || !matchActive) return;
    
    // Local Actions
    if (k === 'q') { player.performAttack("dash"); if(isMultiplayer) conn.send({type:'action', action:'dash'}); }
    if (k === 'r') { player.performAttack("heavy"); if(isMultiplayer) conn.send({type:'action', action:'heavy'}); }
    if (k === 'e') { player.performAttack("rush"); if(isMultiplayer) conn.send({type:'action', action:'rush'}); }
    
    if (['1','2','3','4'].includes(k)) {
        player.useAbility(parseInt(k)-1);
        if(isMultiplayer) conn.send({type:'ability', index:parseInt(k)-1});
    }
});

window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
});

window.addEventListener('mousedown', () => {
    if(player && !player.dead && matchActive) {
        player.performAttack("light");
        if(isMultiplayer) conn.send({type:'action', action:'light'});
    }
});

window.addEventListener('mousemove', e => {
    mouse.x = e.clientX; mouse.y = e.clientY;
});

// --- MULTIPLAYER LOGIC ---

if (isMultiplayer) {
    netStatus.innerText = "INITIALIZING NETWORK...";
    
    // Init Peer
    if (role === 'host') {
        peer = new Peer(roomID); // Host uses the exact Room ID
    } else {
        peer = new Peer(); // Joiner gets random ID
    }

    peer.on('open', (id) => {
        console.log('My Peer ID:', id);
        
        if (role === 'host') {
            netStatus.innerText = `WAITING FOR PLAYER IN ${teamMode}...`;
            peer.on('connection', (c) => {
                conn = c;
                setupConnection();
            });
        } else {
            // Join Logic
            netStatus.innerText = "CONNECTING TO HOST...";
            conn = peer.connect(roomID);
            
            conn.on('open', () => {
                setupConnection();
            });
        }
    });
    
    // If name taken or error
    peer.on('error', (err) => {
        netStatus.innerText = "ERROR: " + err.type;
        alert("Connection Error. Room might be full or ID invalid.");
    });
}

function setupConnection() {
    netStatus.innerText = "CONNECTED! SELECT CHARACTER";
    netStatus.style.color = "#0f0";
    
    conn.on('data', (data) => {
        // 1. Character Select Handling
        if (data.type === 'selected_char') {
            peerCharIndex = data.index;
            peerReady = true;
            if (imReady) {
                startGame(peerCharIndex);
            } else {
                netStatus.innerText = "OPPONENT READY! CHOOSE YOUR FIGHTER";
            }
        }
        
        // 2. Input Syncing (Movement)
        if (data.type === 'input') {
            peerKeys = data.keys;
            peerMouse = data.mouse;
        }
        
        // 3. Actions (Attacks/Abilities)
        if (data.type === 'action') {
            if(!enemy) return;
            if(data.action === 'dash') enemy.performAttack("dash");
            if(data.action === 'rush') enemy.performAttack("rush");
            if(data.action === 'heavy') enemy.performAttack("heavy");
            if(data.action === 'light') enemy.performAttack("light");
        }
        
        if (data.type === 'ability') {
            if(!enemy) return;
            enemy.useAbility(data.index);
        }

        // 4. Hit Confirm (Take Damage if enemy says they hit us)
        if (data.type === 'hit_confirm') {
            player.takeDamage(data.dmg, data.dir, data.kb, data.stun);
            if(data.lift) player.vy = data.lift;
        }

        // 5. Position Correction (Anti-Drift)
        if (data.type === 'sync_pos') {
            if (enemy && !enemy.dead) {
                // Smoothly correct position
                enemy.x = enemy.x * 0.8 + data.x * 0.2;
                enemy.y = enemy.y * 0.8 + data.y * 0.2;
                enemy.hp = data.hp;
            }
        }
    });
}

</script>
</body>
</html>
